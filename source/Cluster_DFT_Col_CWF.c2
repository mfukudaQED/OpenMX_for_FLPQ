/**********************************************************************************
  Cluster_DFT_Col_CWF.c:

     Cluster_DFT_Col_CWF.c is a subroutine to calculate closest Wannier 
     functions to guiding functions during the cluster calculation 
     based on a collinear DFT

  Log of Cluster_DFT_Col_CWF.c:

     15/April/2023  Released by T. Ozaki

**********************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include "openmx_common.h"
#include "lapack_prototypes.h"
#include "mpi.h"
#include <omp.h>
 
#define  measure_time   0

void AllocateArrays_Col_LNAO();
void FreeArrays_Col_LNAO();
double Calc_Hybrid_AO_Col( double ****OLP0, double *****Hks, double *****CDM );
double Calc_MO_in_Bulk_Col( double ****OLP0, double *****Hks, double *****CDM );

static void Allocate_Free_Cluster_Col_CWF( int todo_flag, 
					   int myworld1, 
					   MPI_Comm *MPI_CommWD1,
					   int n,
					   int MaxN,
                                           int TNum_CWFs,
					   double **Cs,
					   double **Hs, 
					   double **Vs,
					   double **Ws,
					   double **EVs_PAO,
					   double ***WFs );

static double Calc_CWF_Cluster(
    int myid0,
    int numprocs0,
    int myid1,
    int numprocs1,
    int myworld1,
    int size_H1,
    int *is2,
    int *ie2,
    int *MP,
    int n,
    int MaxN,
    MPI_Comm *MPI_CommWD1,
    int *Comm_World_StartID1,
    double ****OLP0,
    double **ko,
    double **EVec1 ); 


void solve_evp_real_( int *n1, int *n2, double *Cs, int *na_rows1, double *a, double *Ss, int *na_rows2, int *nblk, 
                      int *mpi_comm_rows_int, int *mpi_comm_cols_int);

void elpa_solve_evp_real_2stage_double_impl_( int *n1, int *n2, double *Cs, int *na_rows1, double *a, double *Ss, int *na_rows2, 
                                              int *nblk, int *na_cols1, int *mpi_comm_rows_int, int *mpi_comm_cols_int, int *mpiworld);



double Cluster_DFT_Col_CWF(
                   char *mode,
                   int SCF_iter,
                   int SpinP_switch,
                   double **ko,
                   double *****nh, 
                   double ****CntOLP,
                   double *****CDM,
                   double *****EDM,
                   double Eele0[2], double Eele1[2],
		   int myworld1,
		   int *NPROCS_ID1,
		   int *Comm_World1,
		   int *NPROCS_WD1,
		   int *Comm_World_StartID1,
		   MPI_Comm *MPI_CommWD1,
                   int *MP,
		   int *is2,
		   int *ie2,
		   double *Ss,
		   double *Cs,
		   double *Hs,
		   double *CDM1,
		   double *EDM1,
		   double *PDM1,
		   int size_H1,
                   int *SP_NZeros,
                   int *SP_Atoms,
                   double **EVec1,
                   double *Work1)
{
  static int firsttime=1;
  int i,j,l,n,n2,n1,i1,i1s,j1,k1,l1;
  int wan,HOMO0,HOMO1,TNum_CWFs;
  int spin,po,num0,num1,ires;
  int ct_AN,k,wanA,tnoA,wanB,tnoB;
  int GA_AN,Anum,loopN,Gc_AN;
  int MA_AN,LB_AN,GB_AN,Bnum,MaxN;
  int wan1,mul,m,bcast_flag;
  int *is1,*ie1;
  double time0,lumos,av_num;
  double *OneD_Mat1;
  double TZ,my_sum,sum,sumE,max_x=60.0;
  double sum0,sum1,sum2,sum3;
  double My_Eele1[2],tmp1,tmp2;
  double Num_State,x,FermiF,Dnum,Dnum2;
  double FermiF2,x2,diffF;
  double dum,ChemP_MAX,ChemP_MIN,spin_degeneracy;
  double TStime,TEtime;
  double FermiEps = 1.0e-13;
  double EV_cut0;
  double res;
  int numprocs0,myid0;
  int numprocs1,myid1;
  int ID,p,world_Snd,world_Rcv; 
  char *Name_Angular[Supported_MaxL+1][2*(Supported_MaxL+1)+1];
  char *Name_Multiple[20];
  double OLP_eigen_cut=Threshold_OLP_Eigen;
  char file_EV[YOUSO10] = ".EV";
  char buf[fp_bsize];          /* setvbuf */
  FILE *fp_EV;
  double stime, etime;
  double time1,time2,time3,time4,time5,time6,time7;

  /* for OpenMP */
  int OMPID,Nthrds,Nprocs;

  MPI_Comm mpi_comm_rows, mpi_comm_cols;
  int mpi_comm_rows_int,mpi_comm_cols_int;
  int info,ig,jg,il,jl,prow,pcol,brow,bcol;
  int ZERO=0, ONE=1;
  double alpha = 1.0; double beta = 0.0;
  int LOCr, LOCc, node, irow, icol;
  double C_spin_i1,mC_spin_i1;
  int sp;

  int ID0,IDS,IDR,Max_Num_Snd_EV,Max_Num_Rcv_EV;
  int *Num_Snd_EV,*Num_Rcv_EV;
  int *index_Snd_i,*index_Snd_j,*index_Rcv_i,*index_Rcv_j;
  double *EVec_Snd,*EVec_Rcv;
  MPI_Status stat;
  MPI_Request request;

  /* for time */
  MPI_Barrier(mpi_comm_level1);
  dtime(&TStime);

  /* MPI */
  MPI_Comm_size(mpi_comm_level1,&numprocs0);
  MPI_Comm_rank(mpi_comm_level1,&myid0);

  MPI_Comm_size(MPI_CommWD1[myworld1],&numprocs1);
  MPI_Comm_rank(MPI_CommWD1[myworld1],&myid1);

  /* calculation of atomic, hybrid, or molecular orbitals */

  if ( CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2 ){
    AllocateArrays_Col_LNAO();
    time1 = Calc_Hybrid_AO_Col(CntOLP, nh, CDM);
  }

  else if (CWF_Guiding_Orbital==3){
    time1 = Calc_MO_in_Bulk_Col(CntOLP, nh, CDM);
  }

  /****************************************************
             calculation of the array size
  ****************************************************/

  n = 0;
  for (i=1; i<=atomnum; i++){
    wanA  = WhatSpecies[i];
    n = n + Spe_Total_CNO[wanA];
  }
  n2 = n + 2;

  /****************************************************
                 Allocation of arrays
  ****************************************************/

  is1 = (int*)malloc(sizeof(int)*numprocs1);
  ie1 = (int*)malloc(sizeof(int)*numprocs1);

  Num_Snd_EV = (int*)malloc(sizeof(int)*numprocs1);
  Num_Rcv_EV = (int*)malloc(sizeof(int)*numprocs1);

  if (measure_time){
    time1 = 0.0;
    time2 = 0.0;
    time3 = 0.0;
    time4 = 0.0;
    time5 = 0.0;
    time6 = 0.0;
    time7 = 0.0;
  }

  if      (SpinP_switch==0) spin_degeneracy = 2.0;
  else if (SpinP_switch==1) spin_degeneracy = 1.0;

  /****************************************************
    calculate the total core charge and TNum_CWFs
  ****************************************************/

  TZ = 0.0;
  for (i=1; i<=atomnum; i++){
    wan = WhatSpecies[i];
    TZ += Spe_Core_Charge[wan];
  }

  if ( CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2 ){

    TNum_CWFs = 0;
    for (i=1; i<=atomnum; i++){
      wan = WhatSpecies[i];
      TNum_CWFs += CWF_Num_predefined[wan];
    }
  }

  else if (CWF_Guiding_Orbital==3){

    int gidx;

    TNum_CWFs = 0;
    for (gidx=0; gidx<Num_CWF_Grouped_Atoms; gidx++){
      TNum_CWFs += Num_CWF_MOs_Group[gidx];
    }
  }
 
  /****************************************************
         find the numbers of partions for MPI
  ****************************************************/

  if ( numprocs1<=n ){

    av_num = (double)n/(double)numprocs1;

    for (ID=0; ID<numprocs1; ID++){
      is1[ID] = (int)(av_num*(double)ID) + 1; 
      ie1[ID] = (int)(av_num*(double)(ID+1)); 
    }

    is1[0] = 1;
    ie1[numprocs1-1] = n; 

  }

  else{

    for (ID=0; ID<n; ID++){
      is1[ID] = ID + 1; 
      ie1[ID] = ID + 1;
    }
    for (ID=n; ID<numprocs1; ID++){
      is1[ID] =  1;
      ie1[ID] = -2;
    }
  }

  /****************************************************
         1. diagonalize the overlap matrix     
         2. search negative eigenvalues
  ****************************************************/

  MPI_Barrier(mpi_comm_level1);

  if (SCF_iter==1){
    Overlap_Cluster_Ss(CntOLP,Cs,MP,myworld1);
  }

  if (SpinP_switch==1 && numprocs0==1){
    Hamiltonian_Cluster_Hs(nh[0],Hs,MP,0,0);
  }
  else{
    for (spin=0; spin<=SpinP_switch; spin++){
      Hamiltonian_Cluster_Hs(nh[spin],Hs,MP,spin,myworld1);
    } 
  }

  if (SCF_iter==1){

    if (measure_time) dtime(&stime);

    MPI_Comm_split(MPI_CommWD1[myworld1],my_pcol,my_prow,&mpi_comm_rows);
    MPI_Comm_split(MPI_CommWD1[myworld1],my_prow,my_pcol,&mpi_comm_cols);

    mpi_comm_rows_int = MPI_Comm_c2f(mpi_comm_rows);
    mpi_comm_cols_int = MPI_Comm_c2f(mpi_comm_cols);

    if (scf_eigen_lib_flag==1){

      F77_NAME(solve_evp_real,SOLVE_EVP_REAL)(&n, &n, Cs, &na_rows, &ko[0][1], Ss, &na_rows, &nblk, &mpi_comm_rows_int, &mpi_comm_cols_int);
    }

    else if (scf_eigen_lib_flag==2){

#ifndef kcomp

      int mpiworld;
      mpiworld = MPI_Comm_c2f(MPI_CommWD1[myworld1]);

      F77_NAME(elpa_solve_evp_real_2stage_double_impl,ELPA_SOLVE_EVP_REAL_2STAGE_DOUBLE_IMPL)(&n, &n, Cs, &na_rows, &ko[0][1], 
                                            Ss, &na_rows, &nblk, &na_cols, &mpi_comm_rows_int, &mpi_comm_cols_int, &mpiworld);

#endif

    }

    MPI_Comm_free(&mpi_comm_rows);
    MPI_Comm_free(&mpi_comm_cols);

    /* print to the standard output */

    if (2<=level_stdout && myid0==Host_ID){
      for (l=1; l<=n; l++){
	printf("  Eigenvalues of OLP  %2d  %18.15f\n",l,ko[0][l]);fflush(stdout);
      }
    }

    /* minus eigenvalues to 1.0e-10 */

    for (l=1; l<=n; l++){
      if (ko[0][l]<0.0) ko[0][l] = 1.0e-10;
    }

    /* calculate S*1/sqrt(ko) */

    for (l=1; l<=n; l++){
      ko[0][l] = 1.0/sqrt(ko[0][l]);
    }

    for(i=0; i<na_rows; i++){
      for(j=0; j<na_cols; j++){
	jg = np_cols*nblk*((j)/nblk) + (j)%nblk + ((np_cols+my_pcol)%np_cols)*nblk + 1;
	Ss[j*na_rows+i] = Ss[j*na_rows+i]*ko[0][jg];
      }
    }

    if (measure_time){
      dtime(&etime);
      time1 += etime - stime; 
    }
  }

  /****************************************************
    calculations of eigenvalues for up and down spins

     Note:
         MP indicates the starting position of
              atom i in arraies H and S
  ****************************************************/

  MPI_Barrier(mpi_comm_level1);

  /* find the maximum states in solved eigenvalues */

  lumos = (double)n*0.200;
  if (lumos<400.0) lumos = 400.0;
  MaxN = (TZ-system_charge)/2 + (int)lumos;
  if (MaxN<TNum_CWFs) MaxN = TNum_CWFs + 30;
  if (n<MaxN) MaxN = n;

  if ( numprocs1<=MaxN ){
    
    av_num = (double)MaxN/(double)numprocs1;
    for (ID=0; ID<numprocs1; ID++){
      is2[ID] = (int)(av_num*(double)ID) + 1; 
      ie2[ID] = (int)(av_num*(double)(ID+1)); 
    }
    
    is2[0] = 1;
    ie2[numprocs1-1] = MaxN; 
  }

  else{

    for (ID=0; ID<MaxN; ID++){
      is2[ID] = ID + 1; 
      ie2[ID] = ID + 1;
    }

    for (ID=MaxN; ID<numprocs1; ID++){
      is2[ID] =  1;
      ie2[ID] =  0;
    }
  }

  /* making data structure of MPI communicaition for eigenvectors */

  for (ID=0; ID<numprocs1; ID++){
    Num_Snd_EV[ID] = 0;
    Num_Rcv_EV[ID] = 0;
  }

  for (i=0; i<na_rows; i++){

    ig = np_rows*nblk*((i)/nblk) + (i)%nblk + ((np_rows+my_prow)%np_rows)*nblk + 1;

    po = 0;
    for (ID=0; ID<numprocs1; ID++){
      if (is2[ID]<=ig && ig <=ie2[ID]){
        po = 1;
        ID0 = ID;
        break;
      }
    }

    if (po==1) Num_Snd_EV[ID0] += na_cols;
  }

  for (ID=0; ID<numprocs1; ID++){
    IDS = (myid1 + ID) % numprocs1;
    IDR = (myid1 - ID + numprocs1) % numprocs1;
    if (ID!=0){
      MPI_Isend(&Num_Snd_EV[IDS], 1, MPI_INT, IDS, 999, MPI_CommWD1[myworld1], &request);
      MPI_Recv(&Num_Rcv_EV[IDR], 1, MPI_INT, IDR, 999, MPI_CommWD1[myworld1], &stat);
      MPI_Wait(&request,&stat);
    }
    else{
      Num_Rcv_EV[IDR] = Num_Snd_EV[IDS];
    }
  }

  Max_Num_Snd_EV = 0;
  Max_Num_Rcv_EV = 0;
  for (ID=0; ID<numprocs1; ID++){
    if (Max_Num_Snd_EV<Num_Snd_EV[ID]) Max_Num_Snd_EV = Num_Snd_EV[ID];
    if (Max_Num_Rcv_EV<Num_Rcv_EV[ID]) Max_Num_Rcv_EV = Num_Rcv_EV[ID];
  }  

  Max_Num_Snd_EV++;
  Max_Num_Rcv_EV++;

  index_Snd_i = (int*)malloc(sizeof(int)*Max_Num_Snd_EV);
  index_Snd_j = (int*)malloc(sizeof(int)*Max_Num_Snd_EV);
  EVec_Snd = (double*)malloc(sizeof(double)*Max_Num_Snd_EV);
  index_Rcv_i = (int*)malloc(sizeof(int)*Max_Num_Rcv_EV);
  index_Rcv_j = (int*)malloc(sizeof(int)*Max_Num_Rcv_EV);
  EVec_Rcv = (double*)malloc(sizeof(double)*Max_Num_Rcv_EV);

  /* for PrintMemory */

  if (firsttime && memoryusage_fileout){
    PrintMemory("Cluster_DFT_Col: is1",sizeof(int)*numprocs1,NULL);
    PrintMemory("Cluster_DFT_Col: ie1",sizeof(int)*numprocs1,NULL);
    PrintMemory("Cluster_DFT_Col: Num_Snd_EV",sizeof(int)*numprocs1,NULL);
    PrintMemory("Cluster_DFT_Col: Num_Snd_EV",sizeof(int)*numprocs1,NULL);
    PrintMemory("Cluster_DFT_Col: index_Snd_i",sizeof(int)*Max_Num_Snd_EV,NULL);
    PrintMemory("Cluster_DFT_Col: index_Snd_j",sizeof(int)*Max_Num_Snd_EV,NULL);
    PrintMemory("Cluster_DFT_Col: index_Rcv_i",sizeof(int)*Max_Num_Rcv_EV,NULL);
    PrintMemory("Cluster_DFT_Col: index_Rcv_j",sizeof(int)*Max_Num_Rcv_EV,NULL);
    PrintMemory("Cluster_DFT_Col: EVec_Snd",sizeof(double)*Max_Num_Snd_EV,NULL);
    PrintMemory("Cluster_DFT_Col: EVec_Rcv",sizeof(double)*Max_Num_Rcv_EV,NULL);
  }
  firsttime=0;

  /* initialize ko */
  for (spin=0; spin<=SpinP_switch; spin++){
    for (i1=1; i1<=n; i1++){
      ko[spin][i1] = 10000.0;
    }
  }

  /* spin=myworld1 */

  spin = myworld1;

 diagonalize:

  if (measure_time) dtime(&stime);

  /* pdgemm */

  /* H * U * 1.0/sqrt(ko[l]) */

  for(i=0; i<na_rows_max*na_cols_max; i++){
    Cs[i] = 0.0;
  }

  Cblacs_barrier(ictxt1,"A");
  F77_NAME(pdgemm,PDGEMM)("N","N",&n,&n,&n,&alpha,Hs,&ONE,&ONE,descH,Ss,&ONE,&ONE,descS,&beta,Cs,&ONE,&ONE,descC);

  /* 1.0/sqrt(ko[l]) * U^+ H * U * 1.0/sqrt(ko[l]) */

  for(i=0; i<na_rows*na_cols; i++){
    Hs[i] = 0.0;
  }

  Cblacs_barrier(ictxt1,"C");
  F77_NAME(pdgemm,PDGEMM)("T","N",&n,&n,&n,&alpha,Ss,&ONE,&ONE,descS,Cs,&ONE,&ONE,descC,&beta,Hs,&ONE,&ONE,descH);

  if (measure_time){
    dtime(&etime);
    time2 += etime - stime;
  }

  /* The output C matrix is distributed by column. */

  if (measure_time) dtime(&stime);

  MPI_Comm_split(MPI_CommWD1[myworld1],my_pcol,my_prow,&mpi_comm_rows);
  MPI_Comm_split(MPI_CommWD1[myworld1],my_prow,my_pcol,&mpi_comm_cols);

  mpi_comm_rows_int = MPI_Comm_c2f(mpi_comm_rows);
  mpi_comm_cols_int = MPI_Comm_c2f(mpi_comm_cols);

  if (scf_eigen_lib_flag==1){
    F77_NAME(solve_evp_real,SOLVE_EVP_REAL)(&n, &MaxN, Hs, &na_rows, &ko[spin][1], Cs, 
                                            &na_rows, &nblk, &mpi_comm_rows_int, &mpi_comm_cols_int);
  }
  else if (scf_eigen_lib_flag==2){

#ifndef kcomp
    int mpiworld;
    mpiworld = MPI_Comm_c2f(MPI_CommWD1[myworld1]);

    F77_NAME(elpa_solve_evp_real_2stage_double_impl,ELPA_SOLVE_EVP_REAL_2STAGE_DOUBLE_IMPL)(&n, &MaxN, Hs, &na_rows, &ko[spin][1], 
									 		    Cs, &na_rows, &nblk, &na_cols, 
                                                                                            &mpi_comm_rows_int, &mpi_comm_cols_int, &mpiworld);
#endif

  }

  MPI_Comm_free(&mpi_comm_rows);
  MPI_Comm_free(&mpi_comm_cols);

  if (measure_time){
    dtime(&etime);
    time3 += etime - stime;
  }

  /****************************************************
      transformation to the original eigenvectors.
                       NOTE 244P
  ****************************************************/

  if (measure_time) dtime(&stime);

  for (i=0; i<na_rows*na_cols; i++) Hs[i] = 0.0;

  Cblacs_barrier(ictxt1,"A");
  F77_NAME(pdgemm,PDGEMM)("T","T",&n,&n,&n,&alpha,Cs,&ONE,&ONE,descC,Ss,&ONE,&ONE,descS,&beta,Hs,&ONE,&ONE,descH);

  /* MPI communications of Hs */

  for (ID=0; ID<numprocs1; ID++){
    
    IDS = (myid1 + ID) % numprocs1;
    IDR = (myid1 - ID + numprocs1) % numprocs1;

    k = 0;
    for(i=0; i<na_rows; i++){
      ig = np_rows*nblk*((i)/nblk) + (i)%nblk + ((np_rows+my_prow)%np_rows)*nblk + 1;
      if (is2[IDS]<=ig && ig <=ie2[IDS]){

        for (j=0; j<na_cols; j++){
          jg = np_cols*nblk*((j)/nblk) + (j)%nblk + ((np_cols+my_pcol)%np_cols)*nblk + 1;
 
          index_Snd_i[k] = ig;
          index_Snd_j[k] = jg;
          EVec_Snd[k] = Hs[j*na_rows+i];
          k++; 
	}
      }
    }

    if (ID!=0){

      if (Num_Snd_EV[IDS]!=0){
        MPI_Isend(index_Snd_i, Num_Snd_EV[IDS], MPI_INT, IDS, 999, MPI_CommWD1[myworld1], &request);
      }
      if (Num_Rcv_EV[IDR]!=0){
        MPI_Recv(index_Rcv_i, Num_Rcv_EV[IDR], MPI_INT, IDR, 999, MPI_CommWD1[myworld1], &stat);
      }
      if (Num_Snd_EV[IDS]!=0){
        MPI_Wait(&request,&stat);
      }

      if (Num_Snd_EV[IDS]!=0){
        MPI_Isend(index_Snd_j, Num_Snd_EV[IDS], MPI_INT, IDS, 999, MPI_CommWD1[myworld1], &request);
      }
      if (Num_Rcv_EV[IDR]!=0){
        MPI_Recv(index_Rcv_j, Num_Rcv_EV[IDR], MPI_INT, IDR, 999, MPI_CommWD1[myworld1], &stat);
      }
      if (Num_Snd_EV[IDS]!=0){
        MPI_Wait(&request,&stat);
      }

      if (Num_Snd_EV[IDS]!=0){
        MPI_Isend(EVec_Snd, Num_Snd_EV[IDS], MPI_DOUBLE, IDS, 999, MPI_CommWD1[myworld1], &request);
      }
      if (Num_Rcv_EV[IDR]!=0){
        MPI_Recv(EVec_Rcv, Num_Rcv_EV[IDR], MPI_DOUBLE, IDR, 999, MPI_CommWD1[myworld1], &stat);
      }
      if (Num_Snd_EV[IDS]!=0){
        MPI_Wait(&request,&stat);
      }
    }
    else{
      for(k=0; k<Num_Snd_EV[IDS]; k++){
        index_Rcv_i[k] = index_Snd_i[k];
        index_Rcv_j[k] = index_Snd_j[k];
        EVec_Rcv[k] = EVec_Snd[k];
      } 
    }

    for(k=0; k<Num_Rcv_EV[IDR]; k++){
      ig = index_Rcv_i[k];
      jg = index_Rcv_j[k];
      m = (jg-1)*(ie2[myid1]-is2[myid1]+1)+ig-is2[myid1]; 
      EVec1[spin][m] = EVec_Rcv[k];
    }
  }

  if (measure_time){
    dtime(&etime);
    time4 += etime - stime;
  }

  if (SpinP_switch==1 && numprocs0==1 && spin==0){
    spin++;
    Hamiltonian_Cluster_Hs(nh[spin],Hs,MP,spin,spin);
    goto diagonalize; 
  }

  /*********************************************** 
    MPI: ko
  ***********************************************/

  if (measure_time) dtime(&stime);

  for (sp=0; sp<=SpinP_switch; sp++){
    MPI_Bcast(&ko[sp][1],MaxN,MPI_DOUBLE,Comm_World_StartID1[sp],mpi_comm_level1);
  }

  time6 += Calc_CWF_Cluster( myid0,numprocs0,myid1,numprocs1,myworld1,
			     size_H1,is2,ie2,MP,n,MaxN,MPI_CommWD1,Comm_World_StartID1,
			     CntOLP,ko,EVec1 );

  if (measure_time){
    printf("Cluster_DFT myid=%2d time1=%7.3f time2=%7.3f time3=%7.3f time4=%7.3f time5=%7.3f time6=%7.3f time7=%7.3f\n",
            myid0,time1,time2,time3,time4,time5,time6,time7);fflush(stdout); 
  }

  /****************************************************
                          Free
  ****************************************************/

  free(EVec_Rcv);
  free(index_Rcv_j);
  free(index_Rcv_i);
  free(EVec_Snd);
  free(index_Snd_j);
  free(index_Snd_i);

  free(Num_Rcv_EV);
  free(Num_Snd_EV);
  free(ie1);
  free(is1);

  /* freeing of arrays */

  if ( CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2 ){
    FreeArrays_Col_LNAO();
  }

  /* for elapsed time */

  MPI_Barrier(mpi_comm_level1);
  dtime(&TEtime);
  time0 = TEtime - TStime;
  return time0;
}

  

double Calc_CWF_Cluster(
    int myid0,
    int numprocs0,
    int myid1,
    int numprocs1,
    int myworld1,
    int size_H1,
    int *is2,
    int *ie2,
    int *MP,
    int n,
    int MaxN,
    MPI_Comm *MPI_CommWD1,
    int *Comm_World_StartID1,
    double ****OLP0,
    double **ko,
    double **EVec1 ) 
{
  int Gc_AN,GB_AN,Mc_AN,h_AN,Gh_AN,wanB,wan1,tno1,wan2,tno2,TNum_CWFs;
  int i,i1,j,l,k,k1,ig,jg,m1,NumCWFs,spin,num,p,q,ID,ID1,mmin,mmax,m;
  int EVec1_size,Max_EVec1_size,sp,*int_data;
  int gidx,Lidx,GA_AN,dim,i0,pnum,idx;
  int *MP2,*MP3,mpi_info[5],fp_Hop_ok=0;
  char fname[YOUSO10];
  FILE *fp_Hop;
  double sum,max_x=60.0,x,FermiF,tmp,w1=1.0e-10;
  double b,e,e0,e1,weight; 
  double *TmpEVec1,*InProd,*InProd_BasisFunc,*C2,**S1;
  double *Cs,*Hs,*Vs,*Ws,*sv,**WFs,*EVs_PAO;
  double **CWF_Charge,**CWF_Energy,*work,**Hop;
  int num_zero_sv=0,rank,lwork,info;
  double Sum_Charges[2],Sum_Energies[2];
  double stime,etime;
  int ZERO=0,ONE=1;
  double alpha=1.0,beta=0.0;
  MPI_Status stat;
  MPI_Request request;
  MPI_Comm mpi_comm_rows, mpi_comm_cols;
  int mpi_comm_rows_int,mpi_comm_cols_int;

  dtime(&stime);

  /* find the total number of CWFs */

  MP2 = (int*)malloc(sizeof(int)*(atomnum+1));

  if (CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2){

    TNum_CWFs = 0;
    for (Gc_AN=1; Gc_AN<=atomnum; Gc_AN++){
      MP2[Gc_AN] = TNum_CWFs;
      wan1 = WhatSpecies[Gc_AN];
      TNum_CWFs += CWF_Num_predefined[wan1];
    }
  }

  else if (CWF_Guiding_Orbital==3){

    TNum_CWFs = 0;
    for (gidx=0; gidx<Num_CWF_Grouped_Atoms; gidx++){
      MP2[gidx] = TNum_CWFs;
      TNum_CWFs += Num_CWF_MOs_Group[gidx];
    }
  }

  /* setting of arrays for SCALAPCK */

  Allocate_Free_Cluster_Col_CWF( 1, myworld1, MPI_CommWD1, n, MaxN, TNum_CWFs, &Cs, &Hs, &Vs, &Ws, &EVs_PAO, &WFs );

  /* find the maximum size of EVec1 */

  EVec1_size = 0;
  for (ID=0; ID<numprocs1; ID++){
    if ( EVec1_size < (n*(ie2[ID]-is2[ID]+1)) ) EVec1_size = n*(ie2[ID]-is2[ID]+1);
  }
  MPI_Allreduce(&EVec1_size,&Max_EVec1_size,1,MPI_INT,MPI_MAX,mpi_comm_level1);

  /* allocation of arrays */

  TmpEVec1 = (double*)malloc(sizeof(double)*Max_EVec1_size);
  InProd = (double*)malloc(sizeof(double)*Max_EVec1_size);
  InProd_BasisFunc = (double*)malloc(sizeof(double)*Max_EVec1_size);
  C2 = (double*)malloc(sizeof(double)*List_YOUSO[7]);
  S1 = (double**)malloc(sizeof(double*)*List_YOUSO[7]);
  for (i=0; i<List_YOUSO[7]; i++) S1[i] = (double*)malloc(sizeof(double)*List_YOUSO[7]);

  sv = (double*)malloc(sizeof(double)*(MaxN+1));

  CWF_Charge = (double**)malloc(sizeof(double*)*2);
  for (spin=0; spin<2; spin++){
    CWF_Charge[spin] = (double*)malloc(sizeof(double)*TNum_CWFs);
    for (i=0; i<TNum_CWFs; i++) CWF_Charge[spin][i] = 0.0;
  }

  CWF_Energy = (double**)malloc(sizeof(double*)*2);
  for (spin=0; spin<2; spin++){
    CWF_Energy[spin] = (double*)malloc(sizeof(double)*TNum_CWFs);
    for (i=0; i<TNum_CWFs; i++) CWF_Energy[spin][i] = 0.0;
  }

  Hop = (double**)malloc(sizeof(double*)*(SpinP_switch+1));
  for (spin=0; spin<(SpinP_switch+1); spin++){ 
    Hop[spin] = (double*)malloc(sizeof(double)*(TNum_CWFs*TNum_CWFs));
    for (p=0; p<(TNum_CWFs*TNum_CWFs); p++) Hop[spin][p] = 0.0;
  }

  /* get size of work and allocate work */

  lwork = -1;
  F77_NAME(pdgesvd,PDGESVD)( "V", "V",
			     &MaxN, &TNum_CWFs,
			     Cs, &ONE, &ONE, desc_CWF3,
			     sv,
			     Ws, &ONE, &ONE, desc_CWF3,
			     Vs, &ONE, &ONE, desc_CWF1,
			     &tmp, 
			     &lwork,
			     &info);

  lwork = (int)tmp + 1;
  work = (double*)malloc(sizeof(double)*lwork);

  //printf("ABC1 Max_States %2d %2d\n",Max_States[0],Max_States[1]);

  /************************************************
       calculation of <LNAO|Bloch functions> 
  ************************************************/

  /* set spin=0 */

  spin = 0;

 spinloop:

  /* initialize Cs and Hs */

  for (i=0; i<na_rows_CWF4*na_cols_CWF4; i++){
    Cs[i] = 0.0;
    Hs[i] = 0.0;
    Ws[i] = 0.0;
    Vs[i] = 0.0;
  }

  /* In the loop of ID, the index of spin is changed regardless of myworld1. */

  for (ID=0; ID<numprocs0; ID++){

    if (ID==myid0){
      if (numprocs0!=1) spin = myworld1;
      ID1 = myid1;
      num = n*(ie2[ID1]-is2[ID1]+1);
      mpi_info[0] = spin;
      mpi_info[1] = ID1;
      mpi_info[2] = num;
      mpi_info[3] = is2[ID1];
      mpi_info[4] = ie2[ID1];
    }

    /* MPI_Bcast of num */

    MPI_Bcast( &mpi_info[0], 5, MPI_INT, ID, mpi_comm_level1 );

    /* set parameters */

    spin = mpi_info[0];
    ID1  = mpi_info[1];
    num  = mpi_info[2];
    mmin = mpi_info[3];
    mmax = mpi_info[4];

    /* initialize InProd and InProd_BasisFunc */

    for (p=0; p<Max_EVec1_size; p++){
      InProd[p] = 0.0;
      InProd_BasisFunc[p] = 0.0;
    }

    if ( num!=0 ){

      /* MPI_Bcast of EVec1 */

      if ( ID==myid0 ){
	for (i=0; i<num; i++){
	  TmpEVec1[i] = EVec1[spin][i];
	}
      }

      MPI_Bcast( &TmpEVec1[0], num, MPI_DOUBLE, ID, mpi_comm_level1 );

      /* store TmpEVec1 into EVs_PAO in the block cyclic form with n x MaxN.  */

      if ( (myworld1==spin && numprocs0!=1) || numprocs0==1 ){ 

	for (j=0; j<na_cols_CWF4; j++){

	  m1 = np_cols_CWF4*nblk_CWF4*((j)/nblk_CWF4) + (j)%nblk_CWF4 
	    + ((np_cols_CWF4+my_pcol_CWF4)%np_cols_CWF4)*nblk_CWF4;

	  if ((mmin-1)<=m1 && m1<=(mmax-1)){ 

	    for (i=0; i<na_rows_CWF4; i++){

	      ig = np_rows_CWF4*nblk_CWF4*((i)/nblk_CWF4) + (i)%nblk_CWF4
		+ ((np_rows_CWF4+my_prow_CWF4)%np_rows_CWF4)*nblk_CWF4;

	      EVs_PAO[j*na_rows_CWF4+i] = TmpEVec1[ ig*(mmax-mmin+1)+m1-mmin+1 ];

	    } // i

	  } // if ((mmin-1)<=m1 && m1<=(mmax-1))
	} // j
      } // if ( (myworld1==spin && numprocs0!=1) || numprocs0==1 )

      /* calculate <Bloch functions|basis functions> */

      for (m=0; m<=(mmax-mmin); m++){  // loop for KS index 
        
	for (Mc_AN=1; Mc_AN<=Matomnum; Mc_AN++){

	  Gc_AN = M2G[Mc_AN];
	  wan1 = WhatSpecies[Gc_AN];
	  tno1 = Spe_Total_CNO[wan1];
      
	  for (i=0; i<tno1; i++){

	    sum = 0.0;

	    for (h_AN=0; h_AN<=FNAN[Gc_AN]; h_AN++){

	      Gh_AN = natn[Gc_AN][h_AN];
	      wan2 = WhatSpecies[Gh_AN];
	      tno2 = Spe_Total_CNO[wan2];

	      for (j=0; j<tno2; j++){
		m1 = (MP[Gh_AN]-1+j)*(mmax-mmin+1) + m;
		C2[j] = TmpEVec1[m1];
	      }      

	      for (j=0; j<tno2; j++){
		sum += OLP0[Mc_AN][h_AN][i][j]*C2[j];
	      } // j

	    } // h_AN

	    /* store <Bloch functions|basis functions> */

	    p = m*n + MP[Gc_AN] - 1 + i;
	    InProd_BasisFunc[p] = sum;

	  } // i
	} // Mc_AN 
      } // m      

      /* MPI_Allreduce of InProd_BasisFunc */       

      MPI_Allreduce( MPI_IN_PLACE, &InProd_BasisFunc[0], (mmax-mmin+1)*n, MPI_DOUBLE, MPI_SUM, mpi_comm_level1 );

      /* AO and HO case: calculate <Bloch functions|guiding functions> */

      if (CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2){

        for (m=0; m<=(mmax-mmin); m++){  // loop for KS index 

	  for (Mc_AN=1; Mc_AN<=Matomnum; Mc_AN++){

	    Gc_AN = M2G[Mc_AN];
	    wan1 = WhatSpecies[Gc_AN];
	    tno1 = Spe_Total_CNO[wan1];
	    NumCWFs = CWF_Num_predefined[wan1];
      
	    for (i=0; i<NumCWFs; i++){

	      sum = 0.0;
	      for (l=0; l<tno1; l++){

		p = m*n + MP[Gc_AN] - 1 + l;  
		sum += InProd_BasisFunc[p]*LNAO1_coes[spin][Mc_AN][tno1*i+l];

	      } // l

   	      q = m*TNum_CWFs + MP2[Gc_AN] + i;
 	      InProd[q] = sum;

	    } // i
	  } // Mc_AN 
	} // m

      } /* end if (CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2) */

      /* MO case: calculate <Bloch functions|guiding functions> */

      else if (CWF_Guiding_Orbital==3){

        for (m=0; m<=(mmax-mmin); m++){  // loop for KS index 
          
          for (gidx=0; gidx<Num_CWF_Grouped_Atoms; gidx++){

	    /* set MP3 */

            MP3 = (int*)malloc(sizeof(int)*CWF_Grouped_Atoms_EachNum[gidx]);

	    k = 0;
	    for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){

	      MP3[Lidx] = k;

	      GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
	      wan1 = WhatSpecies[GA_AN];
	      tno1 = Spe_Total_CNO[wan1];
	      k += tno1; 
	    }
 	    dim = k;

            for (k=0; k<Num_CWF_MOs_Group[gidx]; k++){

              sum = 0.0;

              for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){

                i0 = MP3[Lidx];
                GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
      	        wan1 = WhatSpecies[GA_AN];
	        tno1 = Spe_Total_CNO[wan1];
                
                for (i=0; i<tno1; i++){

  		  p = m*n + MP[GA_AN] - 1 + i;  
                  sum += InProd_BasisFunc[p]*CWF_Guiding_MOs[gidx][spin][k][i0+i];

		  /*
                  printf("GGG1 gidx=%2d k=%2d Lidx=%2d i=%2d p=%2d i0+i=%2d  %15.12f %15.12f\n",gidx,k,Lidx,i,p,i0+i,
                             InProd_BasisFunc[p],CWF_Guiding_MOs[gidx][spin][k][i0+i]);
		  */

		} // i
	      } // Lidx

   	      q = m*TNum_CWFs + MP2[gidx] + k;
 	      InProd[q] = sum;

	    } // k

            /* freeing of MP3 */
 
            free(MP3); 

	  } // gidx
	} // m

      } /* end of else if (CWF_Guiding_Orbital==3) */

      /* MPI_Allreduce of InProd */       

      if (CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2){
        MPI_Allreduce( MPI_IN_PLACE, &InProd[0], (mmax-mmin+1)*TNum_CWFs, MPI_DOUBLE, MPI_SUM, mpi_comm_level1 );
      }

      /* store InProd into an array: Cs in the SCALAPACK form */       

      if ( (myworld1==spin && numprocs0!=1) || numprocs0==1 ){ 

	for (i=0; i<na_rows_CWF3; i++){

	  m1 = np_rows_CWF3*nblk_CWF3*((i)/nblk_CWF3) + (i)%nblk_CWF3
	    + ((np_rows_CWF3+my_prow_CWF3)%np_rows_CWF3)*nblk_CWF3 + 1;

	  if ( mmin<=m1 && m1<=mmax ){ // the base is 1 for mmin and mmax.

	    m = m1 - mmin;  // local index

	    for (j=0; j<na_cols_CWF3; j++){

	      jg = np_cols_CWF3*nblk_CWF3*((j)/nblk_CWF3) + (j)%nblk_CWF3 
		+ ((np_cols_CWF3+my_pcol_CWF3)%np_cols_CWF3)*nblk_CWF3;

	      p = m*TNum_CWFs + jg;
	      Cs[j*na_rows_CWF3+i] = InProd[p];

	    } // j
	  } // if ( mmin<=m1 && m1<=mmax ) 
	} // i

      } // if ( (myworld1==spin && numprocs0!=1) || numprocs0==1 ) 
    } // if ( num!=0 )
  } // ID

  /*
  printf("ABC1 Cs\n");
  for (i=0; i<na_rows_CWF3; i++){
    for (j=0; j<na_cols_CWF3; j++){
      printf("%15.12f ",Cs[j*na_rows_CWF3+i]);
    }
    printf("\n");
  }
  */

  /* set the index of sp */

  if (numprocs0==1) sp = spin;
  else              sp = myworld1; 

  /*********************************************************************
    Disentanling procedure:
    apply weighting based on the KS eigenvalue, 
    where the energy range is specified by CWF.disentangling.Erange. 
  *********************************************************************/

  for (i=0; i<na_rows_CWF3; i++){

    m1 = np_rows_CWF3*nblk_CWF3*((i)/nblk_CWF3) + (i)%nblk_CWF3
      + ((np_rows_CWF3+my_prow_CWF3)%np_rows_CWF3)*nblk_CWF3 + 1;

    e = ko[sp][m1];
    b = 1.0/CWF_disentangling_smearing_kBT;
    e0 = CWF_disentangling_Erange[0] + ChemP; 
    e1 = CWF_disentangling_Erange[1] + ChemP ; 
    weight = 1.0/(exp(b*(e0-e))+1.0) + 1.0/(exp(b*(e-e1))+1.0) - 1.0 + CWF_disentangling_smearing_bound;

    for (j=0; j<na_cols_CWF3; j++){
      Cs[j*na_rows_CWF3+i] *= weight;
    }
  }

  /********************************************************
      Singular Value Decomposition (SVD) of Cs.
      As for how to set desc_CWF1, see also the comment 
      in Allocate_Free_Cluster_Col_CWF
  ********************************************************/

  /* As for the size of Cs, Ws, and Vs, see https://manpages.ubuntu.com/manpages/focal/man3/pdgesvd.3.html */

  F77_NAME(pdgesvd,PDGESVD)( "V", "V",
			     &MaxN, &TNum_CWFs,
			     Cs, &ONE, &ONE, desc_CWF3,   
			     sv,
			     Ws, &ONE, &ONE, desc_CWF3,                              
			     Vs, &ONE, &ONE, desc_CWF1,
			     work,
			     &lwork,
			     &info);


  for (i=0; i<TNum_CWFs; i++){
    printf("ZZZ1 of Cs myworld1=%2d myid0=%2d sp=%2d i=%2d sv=%18.15f\n",myworld1,myid0,sp,i,sv[i]);
  }

  /*
  printf("Ws myid0=%2d myworld1=%2d\n",myid0,myworld1);
  for (i=0; i<na_rows_CWF3; i++){
    for (j=0; j<na_cols_CWF3; j++){
      printf("%8.4f ",Ws[j*na_rows_CWF3+i]);
    }
    printf("\n");
  }

  printf("Vs myid0=%2d myworld1=%2d\n",myid0,myworld1);
  for (i=0; i<na_rows_CWF1; i++){
    for (j=0; j<na_cols_WF1; j++){
      printf("%8.4f ",Vs[j*na_rows_CWF1+i]);
    }
    printf("\n");
  }
  */

  /*******************************************
        Polar Decomposition (PD) of Cs
  *******************************************/

  Cblacs_barrier(ictxt1_CWF1,"A");
  F77_NAME(pdgemm,PDGEMM)( "N","N",
			   &MaxN, &TNum_CWFs, &TNum_CWFs, 
                           &alpha,
			   Ws,&ONE,&ONE,desc_CWF3,
			   Vs,&ONE,&ONE,desc_CWF1,
                           &beta,
			   Hs,&ONE,&ONE,desc_CWF3 );

  /**********************************************************
             calculation of <W_{i0}|H|W_{j0}>
  ***********************************************************/

  /* E x Hs -> Cs */

  for (i=0; i<na_rows_CWF3; i++){

    ig = np_rows_CWF3*nblk_CWF3*((i)/nblk_CWF3) + (i)%nblk_CWF3
      + ((np_rows_CWF3+my_prow_CWF3)%np_rows_CWF3)*nblk_CWF3 + 1;

    for (j=0; j<na_cols_CWF3; j++){

      x = ko[sp][ig];
      Cs[j*na_rows_CWF3+i] = x*Hs[j*na_rows_CWF3+i];
    }
  }

  /* Hs^dag x Cs -> Ws */

  Cblacs_barrier(ictxt1_CWF1,"A");
  F77_NAME(pdgemm,PDGEMM)( "T","N",
			   &TNum_CWFs, &TNum_CWFs, &MaxN,
			   &alpha,
			   Hs,&ONE,&ONE,desc_CWF3,
			   Cs,&ONE,&ONE,desc_CWF3,
			   &beta,
			   Ws,&ONE,&ONE,desc_CWF1 );

  for (i=0; i<na_rows_CWF1; i++){

    ig = np_rows_CWF1*nblk_CWF1*((i)/nblk_CWF1) + (i)%nblk_CWF1
      + ((np_rows_CWF1+my_prow_CWF1)%np_rows_CWF1)*nblk_CWF1;

    if (ig<TNum_CWFs){

      for (j=0; j<na_cols_CWF1; j++){

	jg = np_cols_CWF1*nblk_CWF1*((j)/nblk_CWF1) + (j)%nblk_CWF1 
	  + ((np_cols_CWF1+my_pcol_CWF1)%np_cols_CWF1)*nblk_CWF1;

	if (jg<TNum_CWFs){
	  Hop[sp][jg*TNum_CWFs+ig] = Ws[j*na_rows_CWF1+i]; 
	}
      }
    }
  }

  /**********************************************************
     calculate CWF w.r.t PAOs: 
                    EVs_PAO * Hs -> WFs
           (n x MaxN) * (MaxN x TNum_CWFs) -> (n x TNum_CWFs) 
             WF4               WF3               WF2
  ***********************************************************/

  Cblacs_barrier(ictxt1_CWF4,"A");
  F77_NAME(pdgemm,PDGEMM)( "N","N",
                           &n, &TNum_CWFs, &MaxN, 
                           &alpha,
                           EVs_PAO,   &ONE, &ONE, desc_CWF4,
                           Hs,        &ONE, &ONE, desc_CWF3,
                           &beta,
                           WFs[sp],   &ONE, &ONE, desc_CWF2 );

  /*************************************************************
    CWFs coefficients w.r.t PAOs are stored for calculating 
    values on CWFs on grids 
  **************************************************************/

  if (CWF_fileout_flag==1){

    for (k=0; k<CWF_fileout_Num; k++){

      /* AO or HO case */ 
      if (CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2){
	Gc_AN = CWF_file_Atoms[k];
	wan1 = WhatSpecies[Gc_AN];
	pnum = CWF_Num_predefined[wan1];
	idx = Gc_AN;
      }
      /* MO case */
      else if (CWF_Guiding_Orbital==3){
	gidx = CWF_file_MOs[k];
	pnum = Num_CWF_MOs_Group[gidx]; 
	idx = gidx;
      }

      for (p=0; p<pnum; p++){

	q = MP2[idx] + p;

	for (i=0; i<n; i++) CWF_Coef[sp][k][p][0][0][0][i] = 0.0;

	for (j=0; j<na_cols_CWF2; j++){

	  jg = np_cols_CWF2*nblk_CWF2*((j)/nblk_CWF2) + (j)%nblk_CWF2 
	    + ((np_cols_CWF2+my_pcol_CWF2)%np_cols_CWF2)*nblk_CWF2;

	  if (q==jg){

	    for (i=0; i<na_rows_CWF2; i++){

	      ig = np_rows_CWF2*nblk_CWF2*((i)/nblk_CWF2) + (i)%nblk_CWF2
		+ ((np_rows_CWF2+my_prow_CWF2)%np_rows_CWF2)*nblk_CWF2;

	      CWF_Coef[sp][k][p][0][0][0][ig] = creal(WFs[sp][j*na_rows_CWF2+i]);

	    } // i
	  } // if (q==jg)
	} // j
      } // p
    } // k

    for (k=0; k<CWF_fileout_Num; k++){

      if (CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2){
	Gc_AN = CWF_file_Atoms[k];
	wan1 = WhatSpecies[Gc_AN];
	pnum = CWF_Num_predefined[wan1];
      }
      else if (CWF_Guiding_Orbital==3){
	gidx = CWF_file_MOs[k];
	pnum = Num_CWF_MOs_Group[gidx]; 
      }

      for (p=0; p<pnum; p++){
	MPI_Allreduce( MPI_IN_PLACE, &CWF_Coef[sp][k][p][0][0][0][0], n, MPI_DOUBLE, MPI_SUM, MPI_CommWD1[myworld1]);
      }
    }

  } // end of if (CWF_fileout_flag==1)

  /***********************************************************
   calculations of effective charges and local band energies
  ***********************************************************/

  for (i=0; i<na_rows_CWF3; i++){

    ig = np_rows_CWF3*nblk_CWF3*((i)/nblk_CWF3) + (i)%nblk_CWF3
      + ((np_rows_CWF3+my_prow_CWF3)%np_rows_CWF3)*nblk_CWF3 + 1;

    for (j=0; j<na_cols_CWF3; j++){

      jg = np_cols_CWF3*nblk_CWF3*((j)/nblk_CWF3) + (j)%nblk_CWF3 
	+ ((np_cols_CWF3+my_pcol_CWF3)%np_cols_CWF3)*nblk_CWF3;

      x = (ko[sp][ig] - ChemP)*Beta;
      if (x<=-max_x) x = -max_x;
      if (max_x<=x)  x = max_x;
      FermiF = 1.0/(1.0 + exp(x));
      tmp = FermiF*Hs[j*na_rows_CWF3+i]*Hs[j*na_rows_CWF3+i];

      //printf("QQQ1 i=%2d j=%2d jg=%2d ko=%15.12f x=%15.12f FermiF=%15.12f tmp=%15.12f\n",i,j,jg,ko[sp][jg],x,FermiF,tmp);  

      CWF_Charge[sp][jg] += tmp;
      CWF_Energy[sp][jg] += tmp*ko[sp][ig];
    }
  }

  MPI_Allreduce( MPI_IN_PLACE, &CWF_Charge[sp][0], TNum_CWFs, MPI_DOUBLE, MPI_SUM, MPI_CommWD1[myworld1] );
  MPI_Allreduce( MPI_IN_PLACE, &CWF_Energy[sp][0], TNum_CWFs, MPI_DOUBLE, MPI_SUM, MPI_CommWD1[myworld1] );

  /* goto spinloop if necessary. */

  if (SpinP_switch==1 && numprocs0==1 && spin==0){
    spin++;
    goto spinloop;
  }

  /* MPI: CWF_Charge, CWF_Energy, and CWF_Coef */

  if (SpinP_switch==1 && numprocs0!=1){

    MPI_Bcast(&CWF_Charge[0][0], TNum_CWFs, MPI_DOUBLE, Comm_World_StartID1[0], mpi_comm_level1);
    MPI_Bcast(&CWF_Energy[0][0], TNum_CWFs, MPI_DOUBLE, Comm_World_StartID1[0], mpi_comm_level1);

    MPI_Bcast(&CWF_Charge[1][0], TNum_CWFs, MPI_DOUBLE, Comm_World_StartID1[1], mpi_comm_level1);
    MPI_Bcast(&CWF_Energy[1][0], TNum_CWFs, MPI_DOUBLE, Comm_World_StartID1[1], mpi_comm_level1);

    if (CWF_fileout_flag==1){
      for (k=0; k<CWF_fileout_Num; k++){

	if (CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2){

	  Gc_AN = CWF_file_Atoms[k];
	  wan1 = WhatSpecies[Gc_AN];
          pnum = CWF_Num_predefined[wan1];
	}

        else if (CWF_Guiding_Orbital==3){
  	  gidx = CWF_file_MOs[k];
          pnum = Num_CWF_MOs_Group[gidx]; 
	}

	for (p=0; p<pnum; p++){
	  MPI_Bcast(&CWF_Coef[0][k][p][0][0][0][0], n, MPI_DOUBLE, Comm_World_StartID1[0], mpi_comm_level1);
	  MPI_Bcast(&CWF_Coef[1][k][p][0][0][0][0], n, MPI_DOUBLE, Comm_World_StartID1[1], mpi_comm_level1);
	}
      }
    }
  }

  Sum_Charges[0] = 0.0;
  Sum_Charges[1] = 0.0;
  Sum_Energies[0] = 0.0;;
  Sum_Energies[1] = 0.0;;

  for (spin=0; spin<=SpinP_switch; spin++){
    for (i=0; i<TNum_CWFs; i++){
      Sum_Charges[spin]  += CWF_Charge[spin][i];
      Sum_Energies[spin] += CWF_Energy[spin][i];
    }
  }

  if (SpinP_switch==0){
    Sum_Charges[1]  = Sum_Charges[0];
    Sum_Energies[1] = Sum_Energies[0];
  }

  /**********************************************************
    save the effective charges and local energies to a file
  ***********************************************************/

  if (CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2){

    if ( myid0==Host_ID ){
        
      int i0;
      char file_CWF_Charge[YOUSO10];
      FILE *fp_CWF_Charge;
      char buf[fp_bsize];          /* setvbuf */
      double sumP[2],sumE[2],TZ;

      /* calculate TZ */

      TZ = 0.0;
      for (Gc_AN=1; Gc_AN<=atomnum; Gc_AN++){
	wan1 = WhatSpecies[Gc_AN];
	TZ += Spe_Core_Charge[wan1];
      }

      sprintf(file_CWF_Charge,"%s%s.CWF_Charge",filepath,filename);

      if ((fp_CWF_Charge = fopen(file_CWF_Charge,"w")) != NULL){

	setvbuf(fp_CWF_Charge,buf,_IOFBF,fp_bsize);  /* setvbuf */

	fprintf(fp_CWF_Charge,"\n");
	fprintf(fp_CWF_Charge,"***********************************************************\n");
	fprintf(fp_CWF_Charge,"***********************************************************\n");
	fprintf(fp_CWF_Charge,"              Populations evaluated by CWF                 \n");
	fprintf(fp_CWF_Charge,"***********************************************************\n");
	fprintf(fp_CWF_Charge,"***********************************************************\n\n");

	fprintf(fp_CWF_Charge,"  Total spin moment (muB)  %12.9f\n\n",(Sum_Charges[0]-Sum_Charges[1]));
	fprintf(fp_CWF_Charge,"                    Up spin      Down spin     Sum           Diff\n");
 
	for (Gc_AN=1; Gc_AN<=atomnum; Gc_AN++){

	  wan1 = WhatSpecies[Gc_AN];
	  i0 = MP2[Gc_AN];
	  sumP[0] = 0.0; sumP[1] = 0.0;

	  for (spin=0; spin<=SpinP_switch; spin++){
	    for (i=0; i<CWF_Num_predefined[wan1]; i++){
	      sumP[spin] += CWF_Charge[spin][i0+i];
	    }
	  }
       
	  if (SpinP_switch==0){
	    sumP[1] = sumP[0];
	  }             

	  fprintf(fp_CWF_Charge,"   %4d %4s     %12.9f %12.9f  %12.9f  %12.9f\n",
		  Gc_AN, SpeName[wan1], sumP[0], sumP[1], sumP[0]+sumP[1], sumP[0]-sumP[1]);

	} // Gc_AN

	fprintf(fp_CWF_Charge,"\n");
	fprintf(fp_CWF_Charge," Sum of populations evaluated by CWF\n");
	fprintf(fp_CWF_Charge,"     up   =%12.5f  down          =%12.5f\n",
		Sum_Charges[0],Sum_Charges[1]);
	fprintf(fp_CWF_Charge,"     total=%12.5f  ideal(neutral)=%12.5f\n",
		Sum_Charges[0]+Sum_Charges[1],TZ);     

	/* decomposed populations */

	fprintf(fp_CWF_Charge,"\n\n  Decomposed populations evaluated by CWF\n");

	for (Gc_AN=1; Gc_AN<=atomnum; Gc_AN++){

	  wan1 = WhatSpecies[Gc_AN];
	  i0 = MP2[Gc_AN];

	  fprintf(fp_CWF_Charge,"\n %4d %4s          Up spin      Down spin     Sum           Diff\n",
		  Gc_AN,SpeName[wan1]);
	  fprintf(fp_CWF_Charge,"  orbital index\n");

	  wan1 = WhatSpecies[Gc_AN];
	  sumP[0] = 0.0; sumP[1] = 0.0;

	  if (SpinP_switch==0){
	    for (i=0; i<CWF_Num_predefined[wan1]; i++){
	      fprintf(fp_CWF_Charge,"      %2d         %12.9f %12.9f  %12.9f  %12.9f\n",
		      i,CWF_Charge[0][i0+i],CWF_Charge[0][i0+i],2.0*CWF_Charge[0][i0+i],0.0);
	    }
	  }
	  else if (SpinP_switch==1){
	    for (i=0; i<CWF_Num_predefined[wan1]; i++){
	      fprintf(fp_CWF_Charge,"      %2d         %12.9f %12.9f  %12.9f  %12.9f\n",
		      i,CWF_Charge[0][i0+i],CWF_Charge[1][i0+i],
		      CWF_Charge[0][i0+i]+CWF_Charge[1][i0+i],
		      CWF_Charge[0][i0+i]-CWF_Charge[1][i0+i]);
	    }
	  } 

	} // Gc_AN

	/* fclose fp_CWF_Charge */

	fclose(fp_CWF_Charge);

      } // if ((fp_CWF_Charge = fopen(file_CWF_Charge,"w")) != NULL)

      else{
	printf("Failure of saving the CWF_Charge file.\n");
      }

    } // if ( myid0==Host_ID )

  } /* end of if (CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2) */

  else if (CWF_Guiding_Orbital==3){

    if ( myid0==Host_ID ){
        
      int i0;
      char file_CWF_Charge[YOUSO10];
      FILE *fp_CWF_Charge;
      char buf[fp_bsize];          /* setvbuf */
      double sumP[2],sumE[2],TZ;

      /* calculate TZ */

      TZ = 0.0;
      for (Gc_AN=1; Gc_AN<=atomnum; Gc_AN++){
	wan1 = WhatSpecies[Gc_AN];
	TZ += Spe_Core_Charge[wan1];
      }

      sprintf(file_CWF_Charge,"%s%s.CWF_Charge",filepath,filename);

      if ((fp_CWF_Charge = fopen(file_CWF_Charge,"w")) != NULL){

	setvbuf(fp_CWF_Charge,buf,_IOFBF,fp_bsize);  /* setvbuf */

	fprintf(fp_CWF_Charge,"\n");
	fprintf(fp_CWF_Charge,"***********************************************************\n");
	fprintf(fp_CWF_Charge,"***********************************************************\n");
	fprintf(fp_CWF_Charge,"              Populations evaluated by CWF                 \n");
	fprintf(fp_CWF_Charge,"***********************************************************\n");
	fprintf(fp_CWF_Charge,"***********************************************************\n\n");

	fprintf(fp_CWF_Charge,"  Total spin moment (muB)  %12.9f\n\n",(Sum_Charges[0]-Sum_Charges[1]));
	fprintf(fp_CWF_Charge,"   Group            Up spin      Down spin     Sum           Diff\n");

        for (gidx=0; gidx<Num_CWF_Grouped_Atoms; gidx++){

	  i0 = MP2[gidx];
	  sumP[0] = 0.0; sumP[1] = 0.0;

	  for (spin=0; spin<=SpinP_switch; spin++){
	    for (Lidx=0; Lidx<Num_CWF_MOs_Group[gidx]; Lidx++){
	      sumP[spin] += CWF_Charge[spin][i0+Lidx];
	    }
	  }

	  if (SpinP_switch==0){
	    sumP[1] = sumP[0];
	  }             

	  fprintf(fp_CWF_Charge,"   %4d          %12.9f %12.9f  %12.9f  %12.9f\n",
		  gidx+1, sumP[0], sumP[1], sumP[0]+sumP[1], sumP[0]-sumP[1]);

	} // gidx                 

	fprintf(fp_CWF_Charge,"\n");
	fprintf(fp_CWF_Charge," Sum of populations evaluated by CWF\n");
	fprintf(fp_CWF_Charge,"     up   =%12.5f  down          =%12.5f\n",
		Sum_Charges[0],Sum_Charges[1]);
	fprintf(fp_CWF_Charge,"     total=%12.5f  ideal(neutral)=%12.5f\n",
		Sum_Charges[0]+Sum_Charges[1],TZ);     

	/* decomposed populations */

	fprintf(fp_CWF_Charge,"\n\n  Decomposed populations evaluated by CWF\n");

        for (gidx=0; gidx<Num_CWF_Grouped_Atoms; gidx++){

	  wan1 = WhatSpecies[Gc_AN];
	  i0 = MP2[gidx];

	  fprintf(fp_CWF_Charge,"\n  Group %4d      Up spin      Down spin     Sum           Diff\n",gidx+1);
	  fprintf(fp_CWF_Charge,"  orbital index\n");

	  wan1 = WhatSpecies[Gc_AN];
	  sumP[0] = 0.0; sumP[1] = 0.0;

	  if (SpinP_switch==0){
	    for (i=0; i<Num_CWF_MOs_Group[gidx]; i++){
	      fprintf(fp_CWF_Charge,"      %2d         %12.9f %12.9f  %12.9f  %12.9f\n",
		      i,CWF_Charge[0][i0+i],CWF_Charge[0][i0+i],2.0*CWF_Charge[0][i0+i],0.0);
	    }
	  }
	  else if (SpinP_switch==1){
	    for (i=0; i<Num_CWF_MOs_Group[gidx]; i++){
	      fprintf(fp_CWF_Charge,"      %2d         %12.9f %12.9f  %12.9f  %12.9f\n",
		      i,CWF_Charge[0][i0+i],CWF_Charge[1][i0+i],
		      CWF_Charge[0][i0+i]+CWF_Charge[1][i0+i],
		      CWF_Charge[0][i0+i]-CWF_Charge[1][i0+i]);
	    }
	  } 

	} // gidx

	/* fclose fp_CWF_Charge */

	fclose(fp_CWF_Charge);

      } // if ((fp_CWF_Charge = fopen(file_CWF_Charge,"w")) != NULL)

      else{
	printf("Failure of saving the CWF_Charge file.\n");
      }

    } // if ( myid0==Host_ID )
  }

  /**********************************************************
             save Hop into a file of *.CWF.Hop
  ***********************************************************/

  for (spin=0; spin<(SpinP_switch+1); spin++){ 
    MPI_Allreduce( MPI_IN_PLACE, &Hop[spin][0], (TNum_CWFs*TNum_CWFs), MPI_DOUBLE, MPI_SUM, mpi_comm_level1 );
  }

  if (myid0==Host_ID){

    int_data = (int*)malloc(sizeof(int)*(atomnum+6));

    sprintf(fname,"%s%s.CWF.Hop",filepath,filename);
    if ((fp_Hop = fopen(fname,"w")) != NULL) fp_Hop_ok = 1;

    if ( CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2 ){
      int_data[0] = atomnum;
    }
    else if (CWF_Guiding_Orbital==3){
      int_data[0] = Num_CWF_Grouped_Atoms;
    }    

    int_data[1] = SpinP_switch;
    int_data[2] = 1;
    int_data[3] = 1;
    int_data[4] = 1;
    int_data[5] = TNum_CWFs;

    if ( CWF_Guiding_Orbital==1 || CWF_Guiding_Orbital==2 ){
      for (i=1; i<=atomnum; i++){
        wan1 = WhatSpecies[i];
        int_data[5+i] = CWF_Num_predefined[wan1];
      }
    }
    else if (CWF_Guiding_Orbital==3){
      for (i=0; i<Num_CWF_Grouped_Atoms; i++){
        int_data[6+i] = Num_CWF_MOs_Group[i];
      }
    } 

    if (fp_Hop_ok==1){
      fwrite(&int_data[0],sizeof(int),(int_data[0]+6),fp_Hop);
    }

    for (spin=0; spin<(SpinP_switch+1); spin++){ 
      if (fp_Hop_ok==1){
        fwrite(&Hop[spin][0],sizeof(double),(TNum_CWFs*TNum_CWFs),fp_Hop);
      }
    }

    free(int_data);
    if (fp_Hop_ok==1) fclose(fp_Hop);
  }  

  /**********************************************************
                       freeing of arrays
  ***********************************************************/

  for (spin=0; spin<(SpinP_switch+1); spin++){ 
    free(Hop[spin]);
  }
  free(Hop);

  free(TmpEVec1);
  free(MP2);
  free(InProd);
  free(InProd_BasisFunc);
  free(C2);

  for (i=0; i<List_YOUSO[7]; i++){
    free(S1[i]);
  }
  free(S1);

  free(sv);

  for (spin=0; spin<2; spin++){
    free(CWF_Charge[spin]);
  }
  free(CWF_Charge);

  for (spin=0; spin<2; spin++){
    free(CWF_Energy[spin]);
  }
  free(CWF_Energy);

  free(work);

  /* freeing of arrays for SCALAPCK */

  Allocate_Free_Cluster_Col_CWF( 2, myworld1, MPI_CommWD1, n, MaxN, TNum_CWFs, &Cs, &Hs, &Vs, &Ws, &EVs_PAO, &WFs );

  /* mearuring elapsed time */

  dtime(&etime);
  return (etime-stime);

  /*
  printf("ABC2\n");
  MPI_Finalize();
  exit(0);
  */

}



void Allocate_Free_Cluster_Col_CWF( int todo_flag, 
				    int myworld1, 
				    MPI_Comm *MPI_CommWD1,
				    int n,
				    int MaxN,
                                    int TNum_CWFs,
				    double **Cs,
				    double **Hs, 
				    double **Vs,
				    double **Ws,
				    double **EVs_PAO,
				    double ***WFs )
{
  static int firsttime=1;
  int ZERO=0, ONE=1,info,myid0,numprocs0,myid1,numprocs1;
  int i,k,nblk_m,nblk_m2,wanA,spin,size_EVec1;
  double tmp,tmp1;

  MPI_Barrier(mpi_comm_level1);
  MPI_Comm_size(mpi_comm_level1,&numprocs0);
  MPI_Comm_rank(mpi_comm_level1,&myid0);

  /********************************************
   allocation of arrays 
   
   WF : TNum_CWFs x TNum_CWFs
   WF2: n x TNum_CWFs
   WF3: MaxN x TNum_CWFs 
   WF4: n x MaxN
  ********************************************/

  if (todo_flag==1){

    /* get numprocs1 and myid1 */

    MPI_Comm_size(MPI_CommWD1[myworld1],&numprocs1);
    MPI_Comm_rank(MPI_CommWD1[myworld1],&myid1);

    /* CWF1: setting of BLACS for matrices in size of TNum_CWFs x TNum_CWFs */

    np_cols_CWF1 = (int)(sqrt((float)numprocs1));
    do{
      if((numprocs1%np_cols_CWF1)==0) break;
      np_cols_CWF1--;
    } while (np_cols_CWF1>=2);
    np_rows_CWF1 = numprocs1/np_cols_CWF1;

    /*
     For pdgesvd, I noticed that the same 'nb' has to be used for Cs, Ws, and Vs.
     Otherwise, I encounterd an error. This is the reason why I used the same nb as shown below.  
    */

    nblk_m = NBLK;
    while((nblk_m*np_rows_CWF1>MaxN || nblk_m*np_cols_CWF1>TNum_CWFs) && (nblk_m > 1)){ // the same as for CWF3
    //while((nblk_m*np_rows_CWF1>TNum_CWFs || nblk_m*np_cols_CWF1>TNum_CWFs) && (nblk_m > 1)){
      nblk_m /= 2;
    }
    if(nblk_m<1) nblk_m = 1;

    MPI_Allreduce(&nblk_m,&nblk_CWF1,1,MPI_INT,MPI_MIN,mpi_comm_level1);

    my_prow_CWF1 = myid1/np_cols_CWF1;
    my_pcol_CWF1 = myid1%np_cols_CWF1;

    na_rows_CWF1 = numroc_(&MaxN, &nblk_CWF1, &my_prow_CWF1, &ZERO, &np_rows_CWF1 );  // the same as for CWF3
    na_cols_CWF1 = numroc_(&TNum_CWFs, &nblk_CWF1, &my_pcol_CWF1, &ZERO, &np_cols_CWF1 );

    bhandle1_CWF1 = Csys2blacs_handle(MPI_CommWD1[myworld1]);
    ictxt1_CWF1 = bhandle1_CWF1;

    Cblacs_gridinit(&ictxt1_CWF1, "Row", np_rows_CWF1, np_cols_CWF1);

    MPI_Allreduce(&na_rows_CWF1,&na_rows_max_CWF1,1,MPI_INT,MPI_MAX,MPI_CommWD1[myworld1]);
    MPI_Allreduce(&na_cols_CWF1,&na_cols_max_CWF1,1,MPI_INT,MPI_MAX,MPI_CommWD1[myworld1]);

    descinit_( desc_CWF1, &TNum_CWFs, &TNum_CWFs, &nblk_CWF1, &nblk_CWF1,  
               &ZERO, &ZERO, &ictxt1_CWF1, &na_rows_CWF1,  &info); 

    /*
    printf("ABC2 numprocs1=%2d myid1=%2d n=%2d MaxN=%2d TNum_CWFs=%2d\n",numprocs1,myid1,n,MaxN,TNum_CWFs);
    printf("ABC3 numprocs1=%2d myid1=%2d np_rows_CWF1=%2d np_cols_CWF1=%2d nblk_m=%2d my_prow_CWF1=%2d my_pcol_CWF1=%2d na_rows_CWF1=%2d na_cols_CWF1=%2d bhandle1_CWF1=%2d\n",
	   numprocs1,myid1,np_rows_CWF1,np_cols_CWF1,nblk_m,my_prow_CWF1,my_pcol_CWF1,na_rows_CWF1,na_cols_CWF1,bhandle1_CWF1);

    MPI_Finalize();
    exit(0);
    */

    //printf("ABC0 myid1=%3d min_nm=%2d m=%2d nb=%2d m_loc_A=%2d\n",myid1,TNum_CWFs,TNum_CWFs,nblk_CWF1,na_rows_CWF1);

    /* CWF2: setting of BLACS for matrices in size of n x TNum_CWFs */

    np_cols_CWF2 = (int)(sqrt((float)numprocs1));
    do{
      if((numprocs1%np_cols_CWF2)==0) break;
      np_cols_CWF2--;
    } while (np_cols_CWF2>=2);
    np_rows_CWF2 = numprocs1/np_cols_CWF2;

    nblk_m = NBLK;
    while((nblk_m*np_rows_CWF2>n || nblk_m*np_cols_CWF2>TNum_CWFs) && (nblk_m > 1)){
      nblk_m /= 2;
    }
    if(nblk_m<1) nblk_m = 1;

    MPI_Allreduce(&nblk_m,&nblk_CWF2,1,MPI_INT,MPI_MIN,mpi_comm_level1);

    ictxt1_CWF2 = bhandle1_CWF1;

    my_prow_CWF2 = myid1/np_cols_CWF2;
    my_pcol_CWF2 = myid1%np_cols_CWF2;

    Cblacs_gridinit(&ictxt1_CWF2, "Row", np_rows_CWF2, np_cols_CWF2);

    na_rows_CWF2 = numroc_(&n,         &nblk_CWF2, &my_prow_CWF2, &ZERO, &np_rows_CWF2 );
    na_cols_CWF2 = numroc_(&TNum_CWFs, &nblk_CWF2, &my_pcol_CWF2, &ZERO, &np_cols_CWF2 );

    MPI_Allreduce(&na_rows_CWF2, &na_rows_max_CWF2,1,MPI_INT,MPI_MAX,MPI_CommWD1[myworld1]);
    MPI_Allreduce(&na_cols_CWF2, &na_cols_max_CWF2,1,MPI_INT,MPI_MAX,MPI_CommWD1[myworld1]);

    descinit_( desc_CWF2, &n, &TNum_CWFs, &nblk_CWF2, &nblk_CWF2,  
               &ZERO, &ZERO, &ictxt1_CWF2, &na_rows_CWF2,  &info);

    desc_CWF2[1] = desc_CWF1[1];

    /*
    for (i=0; i<9; i++){
      printf("ABC2 i=%2d  %2d\n",i,desc_CWF2[i]);
    }
    */

    *WFs = (double**)malloc(sizeof(double*)*(SpinP_switch+1));
    for (spin=0; spin<(SpinP_switch+1); spin++){ 
      (*WFs)[spin] = (double*)malloc(sizeof(double)*na_rows_max_CWF2*na_cols_max_CWF2); 
    }

    /* CWF3: setting of BLACS for matrices in size of MaxN x TNum_CWFs */

    np_cols_CWF3 = (int)(sqrt((float)numprocs1));
    do{
      if((numprocs1%np_cols_CWF3)==0) break;
      np_cols_CWF3--;
    } while (np_cols_CWF3>=2);
    np_rows_CWF3 = numprocs1/np_cols_CWF3;

    nblk_m = NBLK;
    while((nblk_m*np_rows_CWF3>MaxN || nblk_m*np_cols_CWF3>TNum_CWFs) && (nblk_m > 1)){
      nblk_m /= 2;
    }
    if(nblk_m<1) nblk_m = 1;

    MPI_Allreduce(&nblk_m,&nblk_CWF3,1,MPI_INT,MPI_MIN,mpi_comm_level1);

    ictxt1_CWF3 = bhandle1_CWF1;

    my_prow_CWF3 = myid1/np_cols_CWF3;
    my_pcol_CWF3 = myid1%np_cols_CWF3;

    Cblacs_gridinit(&ictxt1_CWF3, "Row", np_rows_CWF3, np_cols_CWF3);

    na_rows_CWF3 = numroc_(&MaxN,      &nblk_CWF3, &my_prow_CWF3, &ZERO, &np_rows_CWF3 );
    na_cols_CWF3 = numroc_(&TNum_CWFs, &nblk_CWF3, &my_pcol_CWF3, &ZERO, &np_cols_CWF3 );

    MPI_Allreduce(&na_rows_CWF3, &na_rows_max_CWF3,1,MPI_INT,MPI_MAX,MPI_CommWD1[myworld1]);
    MPI_Allreduce(&na_cols_CWF3, &na_cols_max_CWF3,1,MPI_INT,MPI_MAX,MPI_CommWD1[myworld1]);

    descinit_( desc_CWF3, &MaxN, &TNum_CWFs, &nblk_CWF3, &nblk_CWF3,  
               &ZERO, &ZERO, &ictxt1_CWF3, &na_rows_CWF3,  &info);

    desc_CWF3[1] = desc_CWF1[1];

    /*
    printf("GGG1 myid1=%2d MaxN=%2d TNum_CWFs=%2d nblk_CWF3=%2d na_rows_CWF3=%2d\n",
	   myid1,MaxN,TNum_CWFs,nblk_CWF3,na_rows_CWF3);
    */

    /* CWF4: setting of BLACS for matrices in size of n x MaxN */

    np_cols_CWF4 = (int)(sqrt((float)numprocs1));
    do{
      if((numprocs1%np_cols_CWF4)==0) break;
      np_cols_CWF4--;
    } while (np_cols_CWF4>=2);
    np_rows_CWF4 = numprocs1/np_cols_CWF4;

    nblk_m = NBLK;
    while((nblk_m*np_rows_CWF4>n || nblk_m*np_cols_CWF4>MaxN) && (nblk_m > 1)){
      nblk_m /= 2;
    }
    if(nblk_m<1) nblk_m = 1;

    MPI_Allreduce(&nblk_m,&nblk_CWF4,1,MPI_INT,MPI_MIN,mpi_comm_level1);

    ictxt1_CWF4 = bhandle1_CWF1;

    my_prow_CWF4 = myid1/np_cols_CWF4;
    my_pcol_CWF4 = myid1%np_cols_CWF4;

    Cblacs_gridinit(&ictxt1_CWF4, "Row", np_rows_CWF4, np_cols_CWF4);

    na_rows_CWF4 = numroc_(&n,    &nblk_CWF4, &my_prow_CWF4, &ZERO, &np_rows_CWF4 );
    na_cols_CWF4 = numroc_(&MaxN, &nblk_CWF4, &my_pcol_CWF4, &ZERO, &np_cols_CWF4 );

    MPI_Allreduce(&na_rows_CWF4, &na_rows_max_CWF4,1,MPI_INT,MPI_MAX,MPI_CommWD1[myworld1]);
    MPI_Allreduce(&na_cols_CWF4, &na_cols_max_CWF4,1,MPI_INT,MPI_MAX,MPI_CommWD1[myworld1]);

    descinit_( desc_CWF4, &n, &MaxN, &nblk_CWF4, &nblk_CWF4,
               &ZERO, &ZERO, &ictxt1_CWF4, &na_rows_CWF4, &info);

    desc_CWF4[1] = desc_CWF1[1];

    *Cs = (double*)malloc(sizeof(double)*na_rows_max_CWF4*na_cols_max_CWF4);
    *Hs = (double*)malloc(sizeof(double)*na_rows_max_CWF4*na_cols_max_CWF4);
    *Vs = (double*)malloc(sizeof(double)*na_rows_max_CWF4*na_cols_max_CWF4);
    *Ws = (double*)malloc(sizeof(double)*na_rows_max_CWF4*na_cols_max_CWF4);
    *EVs_PAO = (double*)malloc(sizeof(double)*na_rows_max_CWF4*na_cols_max_CWF4); 

    /*
    for (i=0; i<9; i++){
      printf("ABC1 myid1=%2d i=%2d  WF3=%5d WF3=%5d WF=%5d\n",myid1,i,desc_CWF3[i], desc_CWF3[i], desc_CWF4[i]);
    }
    */

    /* save information of the memory usage */

    if (firsttime && memoryusage_fileout) {
      PrintMemory("Allocate_Free_Cluster_Col_CWF: Cs  ",sizeof(double)*na_rows_max_CWF4*na_cols_max_CWF4,NULL);
      PrintMemory("Allocate_Free_Cluster_Col_CWF: Hs  ",sizeof(double)*na_rows_max_CWF4*na_cols_max_CWF4,NULL);
      PrintMemory("Allocate_Free_Cluster_Col_CWF: Vs  ",sizeof(double)*na_rows_max_CWF4*na_cols_max_CWF4,NULL);
      PrintMemory("Allocate_Free_Cluster_Col_CWF: Ws  ",sizeof(double)*na_rows_max_CWF3*na_cols_max_CWF3,NULL);
      PrintMemory("Allocate_Free_Cluster_Col_CWF: WFs ",sizeof(double)*na_rows_max_CWF2*na_cols_max_CWF2,NULL);
      PrintMemory("Allocate_Free_Cluster_Col_CWF: EVs_PAO",sizeof(double)*na_rows_max_CWF4*na_cols_max_CWF4,NULL);
    }

    firsttime = 0;
  }

  /********************************************
               freeing of arrays 
  ********************************************/

  if (todo_flag==2){

    /* setting for BLACS */

    free(*Cs);
    free(*Hs);
    free(*Vs);
    free(*Ws);

    for (spin=0; spin<(SpinP_switch+1); spin++){ 
      free((*WFs)[spin]);
    }
    free(*WFs);

    free(*EVs_PAO);

    Cfree_blacs_system_handle(bhandle1_CWF1);
    Cblacs_gridexit(ictxt1_CWF1);

    Cfree_blacs_system_handle(bhandle1_CWF2);
    Cblacs_gridexit(ictxt1_CWF2);

    Cfree_blacs_system_handle(bhandle1_CWF3);
    Cblacs_gridexit(ictxt1_CWF3);

    Cfree_blacs_system_handle(bhandle1_CWF4);
    Cblacs_gridexit(ictxt1_CWF4);
  }
}



double Calc_Hybrid_AO_Col( double ****OLP0, double *****Hks, double *****CDM )
{
  int i,j,k,l,n,Mc_AN,Gc_AN,h_AN,Mh_AN,Gh_AN;
  int Cwan,num,wan1,wan2,tno0,tno1,tno2,spin;
  int Nloop,po,p,q,NumLNOs;
  char *JOBVL,*JOBVR;
  int N,A,LDA,LDVL,LDVR,SDIM,LWORK,INFO,*IWORK;
  double ***DMS,*WR,*WI,*VL,*VR,*WORK,RCONDE,RCONDV;
  double *B,sum,sum0,F;

  double TStime,TEtime;
  int ID,IDS,IDR,myid,numprocs,tag=999;
  int size1,size2;
  MPI_Status stat;
  MPI_Request request;

  dtime(&TStime);

  /* MPI */
  MPI_Comm_size(mpi_comm_level1,&numprocs);
  MPI_Comm_rank(mpi_comm_level1,&myid);

  /********************************************
             allocation of arrays
  ********************************************/

  DMS = (double***)malloc(sizeof(double**)*(Matomnum+1));
  for (p=0; p<(Matomnum+1); p++){
    DMS[p] = (double**)malloc(sizeof(double*)*(SpinP_switch+1));
    for (spin=0; spin<=SpinP_switch; spin++){
      DMS[p][spin] = (double*)malloc(sizeof(double)*List_YOUSO[7]*List_YOUSO[7]);
      for (i=0; i<List_YOUSO[7]*List_YOUSO[7]; i++) DMS[p][spin][i] = 0.0;
    }
  }

  WR = (double*)malloc(sizeof(double)*List_YOUSO[7]);
  WI = (double*)malloc(sizeof(double)*List_YOUSO[7]);
  VL = (double*)malloc(sizeof(double)*List_YOUSO[7]*List_YOUSO[7]*2);
  VR = (double*)malloc(sizeof(double)*List_YOUSO[7]*List_YOUSO[7]*2);

  WORK = (double*)malloc(sizeof(double)*List_YOUSO[7]*10);
  IWORK = (int*)malloc(sizeof(int)*List_YOUSO[7]);

  B = (double*)malloc(sizeof(double)*List_YOUSO[7]*List_YOUSO[7]);

  /********************************************
       calculation of DMS defined by DM*S
  ********************************************/

  for (Mc_AN=1; Mc_AN<=Matomnum; Mc_AN++){

    Gc_AN = M2G[Mc_AN];
    wan1 = WhatSpecies[Gc_AN];
    tno1 = Spe_Total_CNO[wan1];

    for (spin=0; spin<=SpinP_switch; spin++){
      for (h_AN=0; h_AN<=FNAN[Gc_AN]; h_AN++){

	Gh_AN = natn[Gc_AN][h_AN];
	wan2 = WhatSpecies[Gh_AN];
	tno2 = Spe_Total_CNO[wan2];

        // include all the contributions of basis functions on the atom

        if (0){ 

	  for (i=0; i<tno1; i++){
	    for (j=0; j<tno1; j++){

	      sum = 0.0;
	      for (k=0; k<tno2; k++){
		sum += CDM[spin][Mc_AN][h_AN][i][k]*OLP0[Mc_AN][h_AN][j][k];
	      }

	      DMS[Mc_AN][spin][tno1*j+i] += sum; 
	    }
	  }
	}

	else{

	  // select only the contributions of the minimal basis

	  int mul,n0=0,n1=0,m; 

	  i = 0;
	  for (l=0; l<=Spe_MaxL_Basis[wan1]; l++){
	    for (mul=0; mul<Spe_Num_Basis[wan1][l]; mul++){
	      for (m=0; m<(2*l+1); m++){
              
		if (CWF_Guiding_AO[wan1][l][mul]==1 && h_AN==0){

		  for (j=0; j<tno1; j++){
		    DMS[Mc_AN][spin][tno1*j+i] = CDM[spin][Mc_AN][h_AN][i][j];
		  }
		}

		i++;
	      }
	    }
	  }
	}

      } /* h_AN */
    } /* spin */
  } /* Mc_AN */

  /********************************************
            diagonalization of DMS
  ********************************************/

  for (spin=0; spin<=SpinP_switch; spin++){

    for (Mc_AN=1; Mc_AN<=Matomnum; Mc_AN++){

      Gc_AN = M2G[Mc_AN];
      wan1 = WhatSpecies[Gc_AN];
      tno1 = Spe_Total_CNO[wan1];
      NumLNOs = CWF_Num_predefined[wan1];

      /* call the dgeev routine in lapack */

      JOBVL = "V";
      JOBVR = "V";
      N = tno1;
      LDA = tno1;
      LDVL = tno1*2;
      LDVR = tno1*2;
      LWORK = tno1*10;

      for (i=0; i<tno1*tno1; i++) B[i] = DMS[Mc_AN][spin][i];

      /* call dgeev */ 

      F77_NAME(dgeev,DGEEV)( JOBVL, JOBVR, &N, B, &LDA, WR, WI, VL, &LDVL, VR, &LDVR, 
                             WORK, &LWORK, &INFO );

      if (INFO!=0){
        printf("warning: INFO=%2d in calling dgeev in a function 'Calc_LNO_WF.'\n",INFO);
      }

      /* ordering the eigenvalues and the orthogonal matrix */

      for (i=0; i<tno1; i++) IWORK[i] = i;
      qsort_double_int2(tno1,WR,IWORK);

      /* calculations of Frobenius norm */

      if (0 && myid==0){

	for (i=0; i<tno1; i++){
	  for (j=0; j<tno1; j++){
	    B[j*tno1+i] = 0.0; 
	  }
	}     

        for (k=0; k<tno1; k++){
          l = IWORK[k];

	  for (i=0; i<tno1; i++){
	    for (j=0; j<tno1; j++){
              B[j*tno1+i] += VR[LDVR*l+i]*WR[k]*VL[LDVL*l+j];
	    }
	  }     
	}

	/*
        printf("DMS Mc_AN=%2d spin=%2d Gc_AN=%2d\n",Mc_AN,spin,Gc_AN);
	for (i=0; i<tno1; i++){
	  for (j=0; j<tno1; j++){
            printf("%10.6f ",DMS[Mc_AN][spin][tno1*j+i]);
	  }
          printf("\n");
	}

        printf("B spin=%2d Gc_AN=%2d\n",spin,Gc_AN);
	for (i=0; i<tno1; i++){
	  for (j=0; j<tno1; j++){
            printf("%10.6f ",B[tno1*j+i]);
	  }
          printf("\n");
	}
	*/
      }

      /* use hybrid orbitals */

      if (CWF_Guiding_Orbital==1){ 

	/* copy VR to LNAO1_coes, where vectors in LNAO1_coes are stored in the column order. */

	for (j=0; j<NumLNOs; j++){

	  k = IWORK[j];
	  for (i=0; i<tno1; i++){
	    LNAO1_coes[spin][Mc_AN][tno1*j+i] = VR[LDVR*k+i];
	  }

	} /* j */
      }

      /* use atomic orbitals */

      else if (CWF_Guiding_Orbital==2){

        int mul,n0=0,n1=0; 

	for (l=0; l<=Spe_MaxL_Basis[wan1]; l++){
	  for (mul=0; mul<Spe_Num_Basis[wan1][l]; mul++){

            for (j=0; j<(2*l+1); j++){

              if (CWF_Guiding_AO[wan1][l][mul]==1){
                LNAO1_coes[spin][Mc_AN][tno1*n1+n0] = 1.0;
                n1++;
	      }

              n0++;
	    }  
	  }
	}
      }

      /* store the eigenvalues */

      for (i=0; i<NumLNOs; i++){
        LNAO1_pops[spin][Mc_AN][i] = WR[i];
      }

      if (0 && myid==0){

        printf("ABC1 Mc_AN=%2d\n",Mc_AN);

	for (i=0; i<tno1; i++){
	  printf("ABC Diago myid=%2d spin=%2d Mc_AN=%2d i=%2d IWORK=%2d WR=%15.11f WI=%15.11f\n",
                      myid,spin,Mc_AN,i,IWORK[i],WR[i],WI[i]);fflush(stdout);
	}

        printf("QQQ myid=%2d Mc_AN=%2d spin=%2d\n",myid,Mc_AN,spin);fflush(stdout);

	printf("WWW1 myid=%2d LNAO1_coes Mc_AN=%2d spin=%2d\n",myid,Mc_AN,spin);fflush(stdout);
	for (i=0; i<tno1; i++){
	  for (j=0; j<NumLNOs; j++){
	    printf("%10.5f ",LNAO1_coes[spin][Mc_AN][tno1*j+i]);fflush(stdout);
	  }
	  printf("\n");fflush(stdout);
	}

        printf("Check orthogonalization\n"); 
	for (i=0; i<tno1; i++){
	  for (j=0; j<tno1; j++){
 
            sum = 0.0;
	    for (k=0; k<tno1; k++){
              sum += VL[LDVL*i+k]*VR[LDVR*j+k];
  	    }
            printf("%10.5f ",sum);
	  }
	  printf("\n");fflush(stdout);
	}

      } // if (0 && myid==0)

    } /* Mc_AN */
  } /* spin */

  /********************************************
             freeing of arrays
  ********************************************/

  for (p=0; p<(Matomnum+1); p++){
    for (spin=0; spin<=SpinP_switch; spin++){
      free(DMS[p][spin]);
    }
    free(DMS[p]);
  }
  free(DMS);

  free(WR);
  free(WI);
  free(VL);
  free(VR);

  free(WORK);
  free(IWORK);

  free(B);

  /* elapsed time */
  dtime(&TEtime);
  return (TEtime-TStime);
}






double Calc_MO_in_Bulk_Col( double ****OLP0, double *****Hks, double *****CDM )
{
  static int first_flag=0;
  int i,j,k,gidx,Lidx,GA_AN,GB_AN,GC_AN,tnum,wan1;
  int Lidx1,Lidx2,i0,j0,MA_AN,h_AN3,h_AN2,spin;
  int tno1,h_AN,Gh_AN,wan2,tno2,dim,l1,l2,l3,p,q;
  int wan3,tno3,RnC,il,jl,ig,jg,brow,bcol,prow,pcol;
  int numprocs,myid;
  int *MP3,**RMI0;
  double sum,TStime,TEtime;
  double **Hmo,**DMmo,*Smo,*****DMmo2,*****Hmo2,****Smo2,**DMS;
  double **OLPgidx,**Hgidx;
  double *WR,*WI,*VL,*VR,*WORK;
  int *IWORK;
  /* for scalpack */
  int ZERO=0, ONE=1, info;
  int nblk_MIB,np_rows_MIB,np_cols_MIB,na_rows_MIB,na_cols_MIB,na_rows_max_MIB,na_cols_max_MIB;
  int my_prow_MIB,my_pcol_MIB,nblk_m;
  int bhandle1_MIB,ictxt1_MIB;
  int desc_MIB[9];

  dtime(&TStime);

  /* MPI */
  MPI_Comm_size(mpi_comm_level1,&numprocs);
  MPI_Comm_rank(mpi_comm_level1,&myid);

  /*****************************************************
                the main loop of gidx
  *****************************************************/

  if (first_flag==1){

    for (gidx=0; gidx<Num_CWF_Grouped_Atoms; gidx++){
      for (spin=0; spin<=SpinP_switch; spin++){
        for (i=0; i<Num_CWF_MOs_Group[gidx]; i++){
          free(CWF_Guiding_MOs[gidx][spin][i]);
	}
        free(CWF_Guiding_MOs[gidx][spin]);
      }
      free(CWF_Guiding_MOs[gidx]);
    }
    free(CWF_Guiding_MOs);
  }

  CWF_Guiding_MOs = (double****)malloc(sizeof(double***)*Num_CWF_Grouped_Atoms);

  for (gidx=0; gidx<Num_CWF_Grouped_Atoms; gidx++){

    /* allocation of MP3 */

    MP3 = (int*)malloc(sizeof(int)*CWF_Grouped_Atoms_EachNum[gidx]);

    /* set MP3 */

    k = 0;
    for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){

      MP3[Lidx] = k;

      GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
      wan1 = WhatSpecies[GA_AN];
      tno1 = Spe_Total_CNO[wan1];
      k += tno1; 
    }
 
    dim = k;

    /* setting for scalapack */

    /*
    np_cols_MIB = (int)(sqrt((float)numprocs));
    do{
      if((numprocs%np_cols_MIB)==0) break;
      np_cols_MIB--;
    } while (np_cols_MIB>=2);
    np_rows_MIB = numprocs/np_cols_MIB;

    nblk_m = NBLK;
    while((nblk_m*np_rows_MIB>dim || nblk_m*np_cols_MIB>dim) && (nblk_m > 1)){
      nblk_m /= 2;
    }
    if(nblk_m<1) nblk_m = 1;

    MPI_Allreduce(&nblk_m,&nblk_MIB,1,MPI_INT,MPI_MIN,mpi_comm_level1);

    my_prow_MIB = myid/np_cols_MIB;
    my_pcol_MIB = myid%np_cols_MIB;

    na_rows_MIB = numroc_(&dim, &nblk_MIB, &my_prow_MIB, &ZERO, &np_rows_MIB );
    na_cols_MIB = numroc_(&dim, &nblk_MIB, &my_pcol_MIB, &ZERO, &np_cols_MIB );

    bhandle1_MIB = Csys2blacs_handle(mpi_comm_level1);
    ictxt1_MIB = bhandle1_MIB;

    Cblacs_gridinit(&ictxt1_MIB, "Row", np_rows_MIB, np_cols_MIB);

    MPI_Allreduce(&na_rows_MIB, &na_rows_max_MIB,1,MPI_INT,MPI_MAX,mpi_comm_level1);
    MPI_Allreduce(&na_cols_MIB, &na_cols_max_MIB,1,MPI_INT,MPI_MAX,mpi_comm_level1);

    descinit_( desc_MIB, &dim, &dim, &nblk_MIB, &nblk_MIB,  
               &ZERO, &ZERO, &ictxt1_MIB, &na_rows_MIB,  &info);
    */

    /* count the number of non-zero elements */

    tnum = 0; 
    for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){

      GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
      wan1 = WhatSpecies[GA_AN];
      tno1 = Spe_Total_CNO[wan1];

      for (h_AN=0; h_AN<=FNAN[GA_AN]; h_AN++){

	Gh_AN = natn[GA_AN][h_AN];
	wan2 = WhatSpecies[Gh_AN];
	tno2 = Spe_Total_CNO[wan2];
        tnum += tno1*tno2;  
      }
    }

    /* allocation of arrays */ 

    DMS = (double**)malloc(sizeof(double*)*(SpinP_switch+1));
    for (spin=0; spin<(SpinP_switch+1); spin++){
      DMS[spin] = (double*)malloc(sizeof(double)*dim*dim);
      for (i=0; i<dim*dim; i++) DMS[spin][i] = 0.0;
    }

    OLPgidx = (double**)malloc(sizeof(double*)*dim);
    for (i=0; i<dim; i++){
      OLPgidx[i] = (double*)malloc(sizeof(double)*dim);
      for (j=0; j<dim; j++) OLPgidx[i][j] = 0.0;
    }

    Hgidx = (double**)malloc(sizeof(double*)*dim);
    for (i=0; i<dim; i++){
      Hgidx[i] = (double*)malloc(sizeof(double)*dim);
      for (j=0; j<dim; j++) Hgidx[i][j] = 0.0;
    }

    Smo = (double*)malloc(sizeof(double)*tnum);
    for (i=0; i<tnum; i++) Smo[i] = 0.0;

    DMmo = (double**)malloc(sizeof(double*)*(SpinP_switch+1));
    for (spin=0; spin<(SpinP_switch+1); spin++){
      DMmo[spin] = (double*)malloc(sizeof(double)*tnum);
      for (i=0; i<tnum; i++) DMmo[spin][i] = 0.0;
    } 

    Hmo = (double**)malloc(sizeof(double*)*(SpinP_switch+1));
    for (spin=0; spin<(SpinP_switch+1); spin++){
      Hmo[spin] = (double*)malloc(sizeof(double)*tnum);
      for (i=0; i<tnum; i++) Hmo[spin][i] = 0.0;
    } 

    Smo2 = (double****)malloc(sizeof(double***)*CWF_Grouped_Atoms_EachNum[gidx]);
    for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){

      GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
      wan1 = WhatSpecies[GA_AN];
      tno1 = Spe_Total_CNO[wan1];
      Smo2[Lidx] = (double***)malloc(sizeof(double**)*(FNAN[GA_AN]+1));

      for (h_AN=0; h_AN<=FNAN[GA_AN]; h_AN++){

	Gh_AN = natn[GA_AN][h_AN];
	wan2 = WhatSpecies[Gh_AN];
	tno2 = Spe_Total_CNO[wan2];
	Smo2[Lidx][h_AN] = (double**)malloc(sizeof(double*)*tno1);

	for (i=0; i<tno1; i++){
	  Smo2[Lidx][h_AN][i] = (double*)malloc(sizeof(double)*tno2);
          for (j=0; j<tno2; j++) Smo2[Lidx][h_AN][i][j] = 0.0;
	}
      }
    }

    DMmo2 = (double*****)malloc(sizeof(double****)*(SpinP_switch+1));
    for (spin=0; spin<(SpinP_switch+1); spin++){

      DMmo2[spin] = (double****)malloc(sizeof(double***)*CWF_Grouped_Atoms_EachNum[gidx]);

      for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){

        GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
        wan1 = WhatSpecies[GA_AN];
        tno1 = Spe_Total_CNO[wan1];
        DMmo2[spin][Lidx] = (double***)malloc(sizeof(double**)*(FNAN[GA_AN]+1));

        for (h_AN=0; h_AN<=FNAN[GA_AN]; h_AN++){

          Gh_AN = natn[GA_AN][h_AN];
          wan2 = WhatSpecies[Gh_AN];
          tno2 = Spe_Total_CNO[wan2];
          DMmo2[spin][Lidx][h_AN] = (double**)malloc(sizeof(double*)*tno1);

          for (i=0; i<tno1; i++){
            DMmo2[spin][Lidx][h_AN][i] = (double*)malloc(sizeof(double)*tno2);
            for (j=0; j<tno2; j++) DMmo2[spin][Lidx][h_AN][i][j] = 0.0;
	  }
	}
      }
    }

    Hmo2 = (double*****)malloc(sizeof(double****)*(SpinP_switch+1));
    for (spin=0; spin<(SpinP_switch+1); spin++){

      Hmo2[spin] = (double****)malloc(sizeof(double***)*CWF_Grouped_Atoms_EachNum[gidx]);

      for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){

        GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
        wan1 = WhatSpecies[GA_AN];
        tno1 = Spe_Total_CNO[wan1];
        Hmo2[spin][Lidx] = (double***)malloc(sizeof(double**)*(FNAN[GA_AN]+1));

        for (h_AN=0; h_AN<=FNAN[GA_AN]; h_AN++){

          Gh_AN = natn[GA_AN][h_AN];
          wan2 = WhatSpecies[Gh_AN];
          tno2 = Spe_Total_CNO[wan2];
          Hmo2[spin][Lidx][h_AN] = (double**)malloc(sizeof(double*)*tno1);

          for (i=0; i<tno1; i++){
            Hmo2[spin][Lidx][h_AN][i] = (double*)malloc(sizeof(double)*tno2);
            for (j=0; j<tno2; j++) Hmo2[spin][Lidx][h_AN][i][j] = 0.0;
	  }
	}
      }
    }

    RMI0 = (int**)malloc(sizeof(int*)*CWF_Grouped_Atoms_EachNum[gidx]);
    for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){
      GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
      RMI0[Lidx] = (int*)malloc(sizeof(int)*(FNAN[GA_AN]+1)*(FNAN[GA_AN]+1));
      for (i=0; i<(FNAN[GA_AN]+1)*(FNAN[GA_AN]+1); i++) RMI0[Lidx][i] = 0;
    }

    /* set Smo, DMmo, and Hmo */

    tnum = 0; 
    for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){

      GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
      MA_AN = F_G2M[GA_AN];

      wan1 = WhatSpecies[GA_AN];
      tno1 = Spe_Total_CNO[wan1];

      for (h_AN=0; h_AN<=FNAN[GA_AN]; h_AN++){

	Gh_AN = natn[GA_AN][h_AN];
	wan2 = WhatSpecies[Gh_AN];
	tno2 = Spe_Total_CNO[wan2];

	for (i=0; i<tno1; i++){
	  for (j=0; j<tno2; j++){

	    if (G2ID[GA_AN]==myid && 0<MA_AN){

	      Smo[tnum] = OLP0[MA_AN][h_AN][i][j];

              for (spin=0; spin<(SpinP_switch+1); spin++){
	        DMmo[spin][tnum] = CDM[spin][MA_AN][h_AN][i][j];
	        Hmo[spin][tnum]  = Hks[spin][MA_AN][h_AN][i][j];
	      }
	    }

	    tnum++; 
	  }
	}
      }
    }    

    /* MPI_Bcast of Smo and DMmo */

    MPI_Allreduce(MPI_IN_PLACE, &Smo[0],tnum,MPI_DOUBLE,MPI_SUM,mpi_comm_level1);
    for (spin=0; spin<(SpinP_switch+1); spin++){
      MPI_Allreduce(MPI_IN_PLACE, &DMmo[spin][0],tnum,MPI_DOUBLE,MPI_SUM,mpi_comm_level1);
      MPI_Allreduce(MPI_IN_PLACE, &Hmo[spin][0], tnum,MPI_DOUBLE,MPI_SUM,mpi_comm_level1);
    }

    /* copy Smo to Smo2, DMmo to DMmo2, and Hmo to Hmo2 */

    k = 0;
    for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){
      GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
      wan1 = WhatSpecies[GA_AN];
      tno1 = Spe_Total_CNO[wan1];

      for (h_AN=0; h_AN<=FNAN[GA_AN]; h_AN++){
	Gh_AN = natn[GA_AN][h_AN];
	wan2 = WhatSpecies[Gh_AN];
	tno2 = Spe_Total_CNO[wan2];

	for (i=0; i<tno1; i++){
	  for (j=0; j<tno2; j++){

            Smo2[Lidx][h_AN][i][j] = Smo[k];

            for (spin=0; spin<(SpinP_switch+1); spin++){
              DMmo2[spin][Lidx][h_AN][i][j] = DMmo[spin][k];
              Hmo2[spin][Lidx][h_AN][i][j] = Hmo[spin][k];
	    }

            k++; 
	  }
	}
      }
    }    

    for (spin=0; spin<(SpinP_switch+1); spin++){ free(DMmo[spin]); } free(DMmo);
    for (spin=0; spin<(SpinP_switch+1); spin++){ free(Hmo[spin]);  } free(Hmo);
    free(Smo);

    /* MPI of RMI1 */

    for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){

      GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
      MA_AN = F_G2M[GA_AN];

      if (G2ID[GA_AN]==myid && 0<MA_AN){
	for (i=0; i<=FNAN[GA_AN]; i++){
	  for (j=0; j<=FNAN[GA_AN]; j++){
            RMI0[Lidx][i*(FNAN[GA_AN]+1)+j] = RMI1[MA_AN][i][j];
	  }
	}
      }

      else{
	for (i=0; i<=FNAN[GA_AN]; i++){
	  for (j=0; j<=FNAN[GA_AN]; j++){
            RMI0[Lidx][i*(FNAN[GA_AN]+1)+j] = 0;
	  }
	}
      }
    }    

    for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){
      GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
      MPI_Allreduce(MPI_IN_PLACE, &RMI0[Lidx][0], (FNAN[GA_AN]+1)*(FNAN[GA_AN]+1), MPI_INT, MPI_SUM, mpi_comm_level1);
    }     

    /* multiplication of DMmos and Smo2 */
    
    for (spin=0; spin<(SpinP_switch+1); spin++){

      for (Lidx1=0; Lidx1<CWF_Grouped_Atoms_EachNum[gidx]; Lidx1++){

        i0 = MP3[Lidx1];
        GA_AN = CWF_Grouped_Atoms[gidx][Lidx1];
	wan1 = WhatSpecies[GA_AN];
	tno1 = Spe_Total_CNO[wan1];

	for (Lidx2=0; Lidx2<CWF_Grouped_Atoms_EachNum[gidx]; Lidx2++){

	  j0 = MP3[Lidx2];
	  GB_AN = CWF_Grouped_Atoms[gidx][Lidx2];
	  wan2 = WhatSpecies[GB_AN];
	  tno2 = Spe_Total_CNO[wan2];

	  /* find h_AN3 */ 
             
	  h_AN3 = -1; 
	  for (h_AN=0; h_AN<=FNAN[GA_AN]; h_AN++){
	    GC_AN = natn[GA_AN][h_AN];
	    RnC = ncn[GC_AN][h_AN];
	    l1 = atv_ijk[RnC][1];
	    l2 = atv_ijk[RnC][2];
	    l3 = atv_ijk[RnC][3];

	    if ( GB_AN==GC_AN && l1==0 && l2==0 && l3==0 ){
	      h_AN3 = h_AN;
	    }
	  }

	  if (0<=h_AN3){

	    for (h_AN=0; h_AN<=FNAN[GA_AN]; h_AN++){

	      GC_AN = natn[GA_AN][h_AN];
	      wan3 = WhatSpecies[GC_AN];
	      tno3 = Spe_Total_CNO[wan3];
	      h_AN2 = RMI0[Lidx1][h_AN3*(FNAN[GA_AN]+1)+h_AN]; 

	      if (0<=h_AN2){

		for (i=0; i<tno1; i++){
		  for (j=0; j<tno2; j++){

		    sum = 0.0;

		    for (k=0; k<tno3; k++){
		      sum += DMmo2[spin][Lidx1][h_AN][i][k]*Smo2[Lidx2][h_AN2][j][k];
		    } /* k */  

		    DMS[spin][(j0+j)*dim + (i0+i)] += sum; 

		  } /* i */
		} /* j */

	      } /* end of if (0<=h_AN2) */
	    } /* h_AN */          
	  } /* if (0<=h_AN3) */
	} /* Lidx2 */
      } /* Lidx1 */
    } /* spin */   

    /* diagonalization of DMS */

    char *JOBVL,*JOBVR;
    int N,LDA,LDVL,LDVR,LWORK;

    JOBVL = "V";
    JOBVR = "V";
    N = dim;
    LDA = dim;
    LDVL = dim*2;
    LDVR = dim*2;
    LWORK = dim*10;

    WR = (double*)malloc(sizeof(double)*dim);
    WI = (double*)malloc(sizeof(double)*dim);
    VL = (double*)malloc(sizeof(double)*dim*dim*2);
    VR = (double*)malloc(sizeof(double)*dim*dim*2);

    WORK = (double*)malloc(sizeof(double)*dim*10);
    IWORK = (int*)malloc(sizeof(int)*dim);
        
    /*
    printf("DMS myid=%2d\n",myid);
    for (i=0; i<dim; i++){
      for (j=0; j<dim; j++){
        printf("%10.5f ",DMS[0][j*dim+i]);
      }
      printf("\n");
    }
    */

    CWF_Guiding_MOs[gidx] = (double***)malloc(sizeof(double**)*(SpinP_switch+1));

    for (spin=0; spin<=SpinP_switch; spin++){

      F77_NAME(dgeev,DGEEV)( JOBVL, JOBVR, &N, &DMS[spin][0], &LDA, WR, WI, VL, &LDVL, VR, &LDVR, 
			     WORK, &LWORK, &info );

      if (info!=0){
	printf("warning: info=%2d in calling dgeev in a function 'Cluster_DFT_Col_CWF.c.'\n",info);
      }

      /*
      for (i=0; i<dim; i++){
	printf("ABC1 i=%2d WR=%15.12f WI=%15.12f\n",i,WR[i],WI[i]); 
      }
      */

      /* construct the hamiltonian and overlap matrices for the group of gidx */

      for (Lidx1=0; Lidx1<CWF_Grouped_Atoms_EachNum[gidx]; Lidx1++){

        i0 = MP3[Lidx1];
        GA_AN = CWF_Grouped_Atoms[gidx][Lidx1];
	wan1 = WhatSpecies[GA_AN];
	tno1 = Spe_Total_CNO[wan1];

        for (h_AN=0; h_AN<=FNAN[GA_AN]; h_AN++){

	  GC_AN = natn[GA_AN][h_AN];
	  RnC = ncn[GC_AN][h_AN];
	  l1 = atv_ijk[RnC][1];
	  l2 = atv_ijk[RnC][2];
	  l3 = atv_ijk[RnC][3];
         
          if (l1==0 && l2==0 && l3==0 ){
            
  	    for (Lidx2=0; Lidx2<CWF_Grouped_Atoms_EachNum[gidx]; Lidx2++){

	      j0 = MP3[Lidx2];
	      GB_AN = CWF_Grouped_Atoms[gidx][Lidx2];
	      wan2 = WhatSpecies[GB_AN];
	      tno2 = Spe_Total_CNO[wan2];

              if (GB_AN==GC_AN){

                for (i=0; i<tno1; i++){
                  for (j=0; j<tno2; j++){

                    OLPgidx[i0+i][j0+j] = Smo2[Lidx1][h_AN][i][j];
                    Hgidx[i0+i][j0+j] = Hmo2[spin][Lidx1][h_AN][i][j];
		  }
		}
	      } 

	    } /* Lidx2 */
	  } /* end of if (l1==0 && l2==0 && l3==0 ) */
	} /* h_AN */   
      } /* Lidx1 */           

      /* calculations of <VR|S|VR>, the normalization of VR, and <VR|H|VR> */

      for (p=0; p<dim; p++){

        /* calculate <VR|S|VR> */

        sum = 0.0;
	for (i=0; i<dim; i++){
	  for (j=0; j<dim; j++){
            sum += OLPgidx[i][j]*VR[LDVR*p+i]*VR[LDVR*p+j];
	  }
	}

        //printf("ZZZ1 p=%2d sum=%15.12f\n",p,sum);

        /* normalization of VR */

        sum = 1.0/sqrt(fabs(sum)); 
       
	for (i=0; i<dim; i++){
          VR[LDVR*p+i] *= sum;  
	}        

        /* calculate <VR|H|VR> */

        sum = 0.0;
	for (i=0; i<dim; i++){
	  for (j=0; j<dim; j++){
            sum += Hgidx[i][j]*VR[LDVR*p+i]*VR[LDVR*p+j];
	  }
	}

        WI[p] = sum; 

        //printf("ZZZ3 p=%2d sum=%15.12f\n",p,sum);

      } /* p */

      /* sort of VR by <VR|H|VR> stored in WI */

      for (p=0; p<dim; p++) IWORK[p] = p;
      qsort_double_int(dim,WI,IWORK);

      for (p=0; p<dim; p++){
        printf("ZZZ4 myid=%2d p=%2d WI=%15.12f WR=%15.12f IWORK=%2d\n",myid,p,WI[p]-ChemP,WR[IWORK[p]],IWORK[p]);
      }

      /* select MOs to be used */

      if (spin==0){

	Num_CWF_MOs_Group[gidx] = 0;
	for (p=0; p<dim; p++){

	  q = IWORK[p];

	  if ( CWF_MO_Erange[gidx][0]<=(WI[p]-ChemP) && (WI[p]-ChemP)<CWF_MO_Erange[gidx][1] 
	       && CWF_MO_Erange[gidx][2]<WR[q] ){

	    Num_CWF_MOs_Group[gidx]++;
	  }

	  if (myid==0){
            printf("QQQ0 gidx=%2d p=%2d Erange=%15.12f %15.12f  %15.12f  %15.12f  \n",
		   gidx,p,CWF_MO_Erange[gidx][0],CWF_MO_Erange[gidx][1],WI[p]-ChemP,WR[q]);
	  }

	}             

        printf("QQQ1 myid=%2d gidx=%2d Num_CWF_MOs_Group=%2d\n",myid,gidx,Num_CWF_MOs_Group[gidx]);
      }


      CWF_Guiding_MOs[gidx][spin] = (double**)malloc(sizeof(double*)*Num_CWF_MOs_Group[gidx]);
      for (i=0; i<Num_CWF_MOs_Group[gidx]; i++){
        CWF_Guiding_MOs[gidx][spin][i] = (double*)malloc(sizeof(double)*dim);
      }             
      first_flag = 1;

      /* store VR to select MOs to CWF_Guiding_MOs */

      if (spin==0){

	i = 0;
	for (p=0; p<dim; p++){

	  q = IWORK[p];

	  if ( CWF_MO_Erange[gidx][0]<=(WI[p]-ChemP) && (WI[p]-ChemP)<=CWF_MO_Erange[gidx][1] 
	       && CWF_MO_Erange[gidx][2]<WR[q] ){

	    for (j=0; j<dim; j++){
	      CWF_Guiding_MOs[gidx][spin][i][j] = VR[LDVR*q+j];

              //printf("VVV1 gidx=%2d i=%2d j=%2d VR=%18.15f\n",gidx,i,j,VR[LDVR*q+j]);
	    }

	    i++;
	  }
	} /* p */             
      }

      else if (spin==1){
        for (i=0; i<Num_CWF_MOs_Group[gidx]; i++){
	  for (j=0; j<dim; j++){
	    CWF_Guiding_MOs[gidx][1][i][j] = CWF_Guiding_MOs[gidx][0][i][j];
	  }
	}
      }

    } /* spin */

    /* free arrays for dgeev */

    free(WR); free(WI); free(VL); free(VR); free(WORK); free(IWORK);

    /* freeing of arrays */ 

    for (spin=0; spin<(SpinP_switch+1); spin++){
      free(DMS[spin]);
    }
    free(DMS);

    for (i=0; i<dim; i++){
      free(OLPgidx[i]);
    }
    free(OLPgidx);

    for (i=0; i<dim; i++){
      free(Hgidx[i]);
    }
    free(Hgidx);

    for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){
      free(RMI0[Lidx]);
    }
    free(RMI0);

    free(MP3);

    for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){

      GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
      wan1 = WhatSpecies[GA_AN];
      tno1 = Spe_Total_CNO[wan1];

      for (h_AN=0; h_AN<=FNAN[GA_AN]; h_AN++){
	for (i=0; i<tno1; i++){
	  free(Smo2[Lidx][h_AN][i]);
	}
        free(Smo2[Lidx][h_AN]);
      }
      free(Smo2[Lidx]);
    }
    free(Smo2);

    for (spin=0; spin<(SpinP_switch+1); spin++){
      for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){

        GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
        wan1 = WhatSpecies[GA_AN];
        tno1 = Spe_Total_CNO[wan1];

        for (h_AN=0; h_AN<=FNAN[GA_AN]; h_AN++){
          for (i=0; i<tno1; i++){
            free(DMmo2[spin][Lidx][h_AN][i]);
	  }
          free(DMmo2[spin][Lidx][h_AN]);
	}
        free(DMmo2[spin][Lidx]);
      }
      free(DMmo2[spin]);
    }
    free(DMmo2);

    for (spin=0; spin<(SpinP_switch+1); spin++){
      for (Lidx=0; Lidx<CWF_Grouped_Atoms_EachNum[gidx]; Lidx++){

        GA_AN = CWF_Grouped_Atoms[gidx][Lidx];
        wan1 = WhatSpecies[GA_AN];
        tno1 = Spe_Total_CNO[wan1];

        for (h_AN=0; h_AN<=FNAN[GA_AN]; h_AN++){
          for (i=0; i<tno1; i++){
            free(Hmo2[spin][Lidx][h_AN][i]);
	  }
          free(Hmo2[spin][Lidx][h_AN]);
	}
        free(Hmo2[spin][Lidx]);
      }
      free(Hmo2[spin]);
    }
    free(Hmo2);

    /* free the scalack setting */

    /*
    Cfree_blacs_system_handle(bhandle1_MIB);
    Cblacs_gridexit(ictxt1_MIB);
    */

  } /* gidx */  

  /* allocate CWF_Coef */

  if ( CWF_Calc==1 && CWF_fileout_flag==1 && CWF_Guiding_Orbital==3 ){

    int wanA;

    j = 0;
    for (i=1; i<=atomnum; i++){
      wanA  = WhatSpecies[i];
      j += Spe_Total_CNO[wanA];
    }

    CWF_Coef = (double*******)malloc(sizeof(double******)*(SpinP_switch+1));
    for (spin=0; spin<(SpinP_switch+1); spin++){
      CWF_Coef[spin] = (double******)malloc(sizeof(double*****)*CWF_fileout_Num);
      for (k=0; k<CWF_fileout_Num; k++){

	gidx = CWF_file_MOs[k];

	CWF_Coef[spin][k] = (double*****)malloc(sizeof(double****)*Num_CWF_MOs_Group[gidx]);
	for (p=0; p<Num_CWF_MOs_Group[gidx]; p++){
	  CWF_Coef[spin][k][p] = (double****)malloc(sizeof(double***)*(2*CWF_Plot_SuperCells[0]+1));
	  for (l1=0; l1<(2*CWF_Plot_SuperCells[0]+1); l1++){
	    CWF_Coef[spin][k][p][l1] = (double***)malloc(sizeof(double**)*(2*CWF_Plot_SuperCells[1]+1));
	    for (l2=0; l2<(2*CWF_Plot_SuperCells[1]+1); l2++){
	      CWF_Coef[spin][k][p][l1][l2] = (double**)malloc(sizeof(double*)*(2*CWF_Plot_SuperCells[2]+1));
	      for (l3=0; l3<(2*CWF_Plot_SuperCells[2]+1); l3++){
		CWF_Coef[spin][k][p][l1][l2][l3] = (double*)malloc(sizeof(double)*j);
		for (i=0; i<j; i++) CWF_Coef[spin][k][p][l1][l2][l3][i] = 0.0;
	      }
	    }
	  }
	}
      }
    } 
  }

  /* elapsed time */
  dtime(&TEtime);
  return (TEtime-TStime);
}





void AllocateArrays_Col_LNAO()
{
  int Mc_AN,Gc_AN,spin,wan1,i;

  /* allocation of arrays */

  LNAO1_coes = (double***)malloc(sizeof(double**)*(SpinP_switch+1));
  for (spin=0; spin<(SpinP_switch+1); spin++){
    LNAO1_coes[spin] = (double**)malloc(sizeof(double*)*(Matomnum+1));
    for (Mc_AN=0; Mc_AN<(Matomnum+1); Mc_AN++){
   
      if (Mc_AN==0){
        wan1 = 0;
      } 
      else{
        Gc_AN = M2G[Mc_AN];
        wan1 = WhatSpecies[Gc_AN];
      }

      LNAO1_coes[spin][Mc_AN] = (double*)malloc(sizeof(double)*(Spe_Total_CNO[wan1]*CWF_Num_predefined[wan1]));
      for (i=0; i<(Spe_Total_CNO[wan1]*CWF_Num_predefined[wan1]); i++){
        LNAO1_coes[spin][Mc_AN][i] = 0.0;
      }
    }  
  }

  LNAO1_pops = (double***)malloc(sizeof(double**)*(SpinP_switch+1));
  for (spin=0; spin<(SpinP_switch+1); spin++){
    LNAO1_pops[spin] = (double**)malloc(sizeof(double*)*(Matomnum+1));
    for (Mc_AN=0; Mc_AN<(Matomnum+1); Mc_AN++){

      if (Mc_AN==0){
        wan1 = 0;
      } 
      else{
        Gc_AN = M2G[Mc_AN];
        wan1 = WhatSpecies[Gc_AN];
      }

      LNAO1_pops[spin][Mc_AN] = (double*)malloc(sizeof(double)*CWF_Num_predefined[wan1]);
      for (i=0; i<CWF_Num_predefined[wan1]; i++){
        LNAO1_pops[spin][Mc_AN][i] = 0.0;
      }
    }
  }
}

void FreeArrays_Col_LNAO()
{
  int Mc_AN,spin;

  for (spin=0; spin<(SpinP_switch+1); spin++){
    for (Mc_AN=0; Mc_AN<(Matomnum+1); Mc_AN++){
      free(LNAO1_coes[spin][Mc_AN]);
    }  
    free(LNAO1_coes[spin]);
  }
  free(LNAO1_coes);

  for (spin=0; spin<(SpinP_switch+1); spin++){
    for (Mc_AN=0; Mc_AN<(Matomnum+1); Mc_AN++){
      free(LNAO1_pops[spin][Mc_AN]);
    }
    free(LNAO1_pops[spin]);
  }
  free(LNAO1_pops);

}



