/*************************************************************************
  analysis_cwf_noncol.c:

  analysis_cwf_noncol.c is a program to read a file of *.CWF.Hop, storing 
  hopping integrals generated by the calculation of the Closest Wannier 
  Functions (CWFs) to a given set of functions within a non-collinear DFT 
  calculation, and diagonalize the Hamiltonian matrix.   

  Log of analysis_cwf_noncol.c:

     05/May/2023  Released by T. Ozaki 

**************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

/* define struct, global variables, and functions */

typedef struct { double r,i; } dcomplex;

#define print_data  0
#define PI          3.1415926535897932384626

int atomnum,SpinP_switch,NumCell_1,NumCell_2,NumCell_3,TNum_CWFs;
int *Num_CWFs;
dcomplex  ****Hop;

void zheevx_(char *JOBZ, char *RANGE, char *UPLO, int *N, dcomplex *A, int *LDA, double *VL, double *VU, int *IL, int *IU,
                        double *ABSTOL, int *M, double *W, dcomplex *Z, int *LDZ, dcomplex *WORK, int *LWORK, double *RWORK,
                        int *IWORK, int *IFAIL, int *INFO);


void read_CWF_Hop(char *mode, char *argv[]);
void lapack_zheevx(int N, dcomplex *A, double *W);


int main(int argc, char *argv[]) 
{
  int n1,n2,n3,l1,l2,l3,i,j;
  double k1,k2,k3,co,si,kRn;
  double *eval;
  dcomplex *Hk;

  /* read the .CWF.Hop file */

  read_CWF_Hop("read",argv);

  /* making of H(k) */

  Hk = (dcomplex*)malloc(sizeof(dcomplex)*(TNum_CWFs*TNum_CWFs));
  eval = (double*)malloc(sizeof(double)*TNum_CWFs);

  int n;

  k1 = -0.42857142857142857143;
  k2 = -0.42857142857142857143;
  k3 = -0.28571428571428571429;

  for (i=0; i<(TNum_CWFs*TNum_CWFs); i++){ Hk[i].r = 0.0; Hk[i].i = 0.0; }

  for ( l1=-(NumCell_1-1)/2; l1<=(NumCell_1-1)/2; l1++ ){

    n1 = l1 + (NumCell_1-1)/2; 

    for ( l2=-(NumCell_2-1)/2; l2<=(NumCell_2-1)/2; l2++ ){

      n2 = l2 + (NumCell_2-1)/2; 

      for ( l3=-(NumCell_3-1)/2; l3<=(NumCell_3-1)/2; l3++ ){

	n3 = l3 + (NumCell_3-1)/2; 

	kRn = k1*(double)l1 + k2*(double)l2 + k3*(double)l3;
	si = sin(2.0*PI*kRn);
	co = cos(2.0*PI*kRn);

	for (i=0; i<TNum_CWFs; i++){
	  for (j=0; j<TNum_CWFs; j++){

	    Hk[j*TNum_CWFs+i].r += co*Hop[n1][n2][n3][j*TNum_CWFs+i].r - si*Hop[n1][n2][n3][j*TNum_CWFs+i].i;
	    Hk[j*TNum_CWFs+i].i += si*Hop[n1][n2][n3][j*TNum_CWFs+i].r + co*Hop[n1][n2][n3][j*TNum_CWFs+i].i;

	  } // j
	} // i       
      } // l3
    } // l2
  } // l1

  if (print_data){      
    printf("Real Hk\n");
    for (i=0; i<TNum_CWFs; i++){
      for (j=0; j<TNum_CWFs; j++){
	printf("%12.8f ",Hk[j*TNum_CWFs+i].r);
      }
      printf("\n");
    }

    printf("Imag Hk\n");
    for (i=0; i<TNum_CWFs; i++){
      for (j=0; j<TNum_CWFs; j++){
	printf("%12.8f ",Hk[j*TNum_CWFs+i].i);
      }
      printf("\n");
    }
  }

  /* diagonalizing of H(k) */

  lapack_zheevx(TNum_CWFs, Hk, eval);      
    
  for (i=0; i<TNum_CWFs; i++){
    printf("i=%2d eval=%18.15f\n",i,eval[i]);
  }

  /* freeing of arrays */

  free(eval);
  free(Hk);

  read_CWF_Hop("free",argv);

  exit(0);
}


void read_CWF_Hop(char *mode, char *argv[])
{
  int n1,n2,n3,i,j;
  int i_vec[20];
  FILE *fp;

  /***********************************************************
                 if (strcasecmp(mode,"read")==0)
  ***********************************************************/

  if (strcasecmp(mode,"read")==0){

    if ((fp = fopen(argv[1],"r")) != NULL){

      /* read the basic information */  

      fread(i_vec,sizeof(int),6,fp);
      atomnum      = i_vec[0];
      SpinP_switch = i_vec[1];
      NumCell_1    = i_vec[2];
      NumCell_2    = i_vec[3];
      NumCell_3    = i_vec[4];
      TNum_CWFs    = i_vec[5];

      if (print_data){      
	printf("atomnum=%2d\n",atomnum);
	printf("SpinP_switch=%2d\n",SpinP_switch);
	printf("NumCell_1=%2d\n",NumCell_1);
	printf("NumCell_2=%2d\n",NumCell_2);
	printf("NumCell_3=%2d\n",NumCell_3);
	printf("TNum_CWFs=%2d\n",TNum_CWFs);
      }

      /* allocation of arrays */

      Num_CWFs = (int*)malloc(sizeof(int)*(atomnum+1));

      Hop = (dcomplex****)malloc(sizeof(dcomplex***)*NumCell_1);
      for ( n1=0; n1<NumCell_1; n1++ ){
	Hop[n1] = (dcomplex***)malloc(sizeof(dcomplex**)*NumCell_2);
	for ( n2=0; n2<NumCell_2; n2++ ){
	  Hop[n1][n2] = (dcomplex**)malloc(sizeof(dcomplex*)*NumCell_3);
	  for ( n3=0; n3<NumCell_3; n3++ ){
	    Hop[n1][n2][n3] = (dcomplex*)malloc(sizeof(dcomplex)*(TNum_CWFs*TNum_CWFs));
	  }
	}
      }

      /* read the number of CWFs allocated to each atom */  

      fread(&Num_CWFs[1],sizeof(int),atomnum,fp);

      /* read Hop */  

      for ( n1=0; n1<NumCell_1; n1++ ){
	for ( n2=0; n2<NumCell_2; n2++ ){
	  for ( n3=0; n3<NumCell_3; n3++ ){
	    fread(&Hop[n1][n2][n3][0],sizeof(dcomplex),(TNum_CWFs*TNum_CWFs),fp);
	  }
	}
      }

      if (print_data){      
	for ( n1=0; n1<NumCell_1; n1++ ){
	  for ( n2=0; n2<NumCell_2; n2++ ){
	    for ( n3=0; n3<NumCell_3; n3++ ){
	      for (i=0; i<TNum_CWFs; i++){
		for (j=0; j<TNum_CWFs; j++){
		  printf("n1=%2d n2=%2d n3=%2d i=%2d j=%2d Hop=%18.15f %18.15f\n",
			 n1,n2,n3,i,j,Hop[n1][n2][n3][j*TNum_CWFs+i].r,Hop[n1][n2][n3][j*TNum_CWFs+i].i);
		}
	      }
	    }
	  }
	}
      }

      /* fclose(fp) */

      fclose(fp);
    }

    else {
      printf("Failure of reading the .CWF.Hop file (%s).\n",argv[1]);fflush(stdout);
      exit(0); 
    }

  } /* end of if (strcasecmp(mode,"read")==0) */

  /***********************************************************
                 if (strcasecmp(mode,"free")==0)
  ***********************************************************/

  else if (strcasecmp(mode,"free")==0){

    free(Num_CWFs);

    for ( n1=0; n1<NumCell_1; n1++ ){
      for ( n2=0; n2<NumCell_2; n2++ ){
	for ( n3=0; n3<NumCell_3; n3++ ){
	  free(Hop[n1][n2][n3]);
	}
	free(Hop[n1][n2]);
      }
      free(Hop[n1]);
    }
    free(Hop);
  } 

}


void lapack_zheevx(int N, dcomplex *A, double *W)
{
  char *JOBZ="V";
  char *UPLO="L";
  char *RANGE="A";
  int i,LDA,LDZ,IL,IU,LWORK;
  int *IWORK,*IFAIL,M,INFO;
  double ABSTOL=1.0e-14;
  double VL,VU;
  double *RWORK;
  dcomplex *WORK,*Z;

  /* allocation of arrays */

  LDA = N;  LDZ = N;
  IL = 1;   IU = N;

  LWORK = 3*N;
  WORK  = (dcomplex*)malloc(sizeof(dcomplex)*LWORK);
  RWORK = (double*)malloc(sizeof(double)*7*N);
  IWORK = (int*)malloc(sizeof(int)*5*N);
  IFAIL = (int*)malloc(sizeof(int)*N);
  Z     = (dcomplex*)malloc(sizeof(dcomplex)*(N*N));

  /* call zheevx */

  zheevx_(JOBZ, RANGE, UPLO, &N, A, &LDA, &VL, &VU, &IL, &IU,
          &ABSTOL, &M, W, Z, &LDZ, WORK, &LWORK, RWORK,
          IWORK, IFAIL, &INFO );

  for (i=0; i<(N*N); i++) A[i] = Z[i];

  /* freeing of arrays */

  free(WORK);
  free(RWORK);
  free(IWORK);
  free(IFAIL);
  free(Z);
}
